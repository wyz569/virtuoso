
<html><head><title>Periodic Steady-State Analysis (pss)</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="rrohit" />
<meta name="CreateDate" content="2023-08-31" />
<meta name="CreateTime" content="1693484709" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="Provides reference information on the Spectre circuit simulator." />
<meta name="DocTitle" content="Spectre Circuit Simulator Reference" />
<meta name="DocType" content="Reference" />
<meta name="FileTitle" content="Periodic Steady-State Analysis (pss)" />
<meta name="FileType" content="Chapter" />
<meta name="FMWikiRelease" content="FM-Wiki-4.0.0" />
<meta name="Keyword" content="spectreref" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2023-08-31" />
<meta name="ModifiedTime" content="1693484709" />
<meta name="NextFile" content="chap3_re_Periodic_STB_Analysis_pstb.html" />
<meta name="Order" content="2" />
<meta name="Group" content="Spectre Simulator" />
<meta name="Platform" content="Custom IC Design" />
<meta name="PrevFile" content="chap3_re_Periodic_S-Parameter_Analysis_psp.html" />
<meta name="c_product" content="Spectre" />
<meta name="Product" content="Spectre" />
<meta name="ProductFamily" content="Spectre" />
<meta name="ProductVersion" content="23.1" />
<meta name="RightsManagement" content="Copyright 2023 Cadence Design Systems Inc." />
<meta name="Title" content="Spectre Circuit Simulator Reference -- Periodic Steady-State Analysis (pss)" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="prod_feature" content="" />
<meta name="prod_subfeature" content="" />
<meta name="new_topic" content="No" />
<meta name="spotlight_topic" content="0" />
<meta name="Version" content="23.1" />
<meta name="SpaceKey" content="spectreref231" />
<meta name="webflare-version" content="2.5" />
<link rel="stylesheet" href="styles/webflare.css" type="text/css" />


  <script>/*<![CDATA[*/
 document.addEventListener("DOMContentLoaded", function(event) {  document.querySelectorAll("img").forEach((img, index) => {
if (img.hasAttribute("usemap")){return;}else{img.classList.add("cursorclass");} img.addEventListener("click", (e) => {if(img.hasAttribute("usemap")){            img.setAttribute("style","cursor:none;");return;};document.querySelector("#cad_image_modal").classList.add("opac");document.querySelector("#cad_image_modal_center").innerHTML = `<img style="position:absolute;top:0;bottom:0;left:0;right:0;margin: auto;max-height:95%;"  src="${e.target.src}">`;});});});
/*]]>*/</script> 




 <style>/*<![CDATA[*/
.cursorclass{cursor:pointer;}#cad_image_modal{position:fixed;left:0;top:0;width:100%;background:#00000099;overflow:hidden;height:0;opacity:0;transition: height 0ms 1s, opacity 1s 0ms;}#cad_image_modal.opac{height: 100%;opacity: 1;transition: height 0ms 0ms, opacity 1s 0ms;}#cad_image_modal span{position:fixed;right:10px;top:10px;cursor:pointer;color:#fff;}
/*]]>*/</style> 
</head><body style="background-color: #FFFFFF;"><a name="pagetop"></a>
<!-- Begin Buttons -->
<header><div class="docHeadr">Product Documentation<img src="icons/Cadence-Logo.jpg" /></div><nav class="blueHead"><ul><li><a class="content" href="spectrerefTOC.html">Contents</a></li><li><a class="prev" href="chap3_re_Periodic_S-Parameter_Analysis_psp.html" title="Periodic S-Parameter Analysis (psp)">Periodic S-Parameter Analysis  ...</a></li><li style="float: right;"><a class="viewPrint" href="spectreref.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="chap3_re_Periodic_STB_Analysis_pstb.html" title="Periodic STB Analysis (pstb)">Periodic STB Analysis (pstb)</a></li></ul></nav></header>
<!-- End Buttons -->
<h5><center>Spectre Circuit Simulator Reference<br />Product Version 23.1, September 2023</center></h5><div id="main-content" style="min-height: 50vh; margin-left: 5%; margin-right: 2%;"><a name="#firstpage"></a>

<a id="Filename:re_Periodic_Steady-State_Analysis_pss" title="Periodic Steady-State Analysis (pss)"></a><h3>
<a id="pgfId-1698398"></a>Periodic Steady-State Analysis (pss)<a id="marker-1698397"></a></h3>
<h4>
<a id="pgfId-1698400"></a>Description<a id="marker-1698399"></a></h4>

<p>
<a id="pgfId-1698401"></a>This analysis computes the periodic steady-state (PSS) response of a circuit by using harmonic balance (in the frequency domain) or shooting (in the time domain). The simulation time of PSS analysis is independent of the time-constants of the circuit. In addition, PSS analysis determines the periodic operating point for the circuit. The periodic operating point can then be used during a periodic time-varying small-signal analysis, such as PAC, PXF, PNOISE, PSP, or PSTB.</p>
<p>
<a id="pgfId-1698402"></a>Generally, harmonic balance (HB) is very efficient in simulating weak non-linear circuits while shooting is more suitable for highly non-linear circuits with sharply rising and falling signals. HB is also advantageous over shooting in handling frequency dependent components, such as delay, transmission line, and S-parameter data.</p>
<p>
<a id="pgfId-1698403"></a>PSS analysis can handle both autonomous (non-driven) and driven (non-autonomous) circuits. Autonomous circuits,even though they are not driven by a time-varying stimulus, generate non-constant waveforms. Driven circuits require some time-varying stimulus to generate a time-varying response. The most common example of an autonomous circuit is an oscillator. Common driven circuits include amplifiers, filters, and mixers. When PSS is applied to autonomous circuits, it requires you to specify a pair of nodes, <code>p</code> and <code>n</code>. This is how PSS analysis determines whether it is being applied to an autonomous or a driven circuit. If the pair of nodes is supplied, PSS assumes the circuit is autonomous; if not, the circuit is assumed to be driven.</p>
<p>
<a id="pgfId-1698404"></a></p>
<p>
<a id="pgfId-1698405"></a>With driven circuits, specify the analysis period, or its corresponding fundamental frequency <code>fund</code>. The <code>period</code> must be an integer multiple of the period of the drive signal or signals. Autonomous circuits have no drive signal, and the actual period of oscillation is not known precisely in advance. Instead, you specify an estimate of the oscillation period and PSS analysis computes the precise period along with the periodic solution waveforms.</p>
<p>
<a id="pgfId-1698406"></a>PSS analysis consists of two phases, an initial transient phase, which initializes the circuit, and the shooting or harmonic balance phase, which computes the periodic steady-state solution. The transient phase consists of three intervals. The first interval starts at <code>tstart</code>, which is normally 0, and continues through the onset of periodicity <code>tonset</code> for the independent sources. The onset of periodicity, which is automatically generated, is the minimum time for which all sources are periodic. The second interval is an optional user-specified stabilization interval whose length is <code>tstab</code>. The final interval length is <code>period</code> for driven circuits, or four times <code>period</code> for autonomous circuits. This interval has a special use for the autonomous PSS analysis, that is, the PSS analysis monitors the waveforms in the circuit and develops a better estimate of the oscillation period. After the initial transient phase is complete, the shooting or HB phase begins. In this phase, the circuit is iteratively solved using Newton method to find the periodic steady-state solution (and the period when applied to autonomous circuits). </p>

<h4>
<a id="pgfId-1698408"></a>Syntax<a id="marker-1698407"></a></h4>
<a id="pgfId-1698409"></a><pre class="webflare-courier-new webflare-syx-syntax codeContent">
Name  [p]  [n] pss parameter=<code><em>value ...</em></code></pre>
<h4>
<a id="pgfId-1698410"></a>Parameters</h4>

<p>
<a id="pgfId-1698496"></a>Simulation interval parameters</p>
<table class="webflareTable" id="#id1698411">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1698413"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698419"></a><code>period</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698421"></a><code> (s)</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698423"></a>Steady state analysis period (or its estimate for autonomous circuits).</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698425"></a><code>fund</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698427"></a><code> (Hz)</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698429"></a>Alternative to period specification. Steady state analysis fundamental frequency (or its estimate for autonomous circuits).</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698431"></a><code>autofund</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698433"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698435"></a>If the value is yes, the program ignores period/fund value and calculates the fundamental frequency automatically from source information. Possible values are no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698437"></a><code>harms</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698439"></a><code>9 for shooting, 10 for HB</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698441"></a>For shooting, it is the number of solution harmonics to output when outputtype=<code>freq</code> or <code>all</code>; for HB, it directly determines the solution dimension to be solved and impacts the accuracy and convergence of the simulation.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698443"></a><code>autoharms</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698445"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698447"></a>Activates automatic harmonic number calculation in harmonic balance. Applies only if tstab&gt;0 or if autotstab=yes. If a steady-state is reached, Spectre does a spectrum analysis to calculate the optimal number of harmonics for HB. The minimum number of harmonics is specified by maxharms. If steady-state is not reached to sufficient tolerance, autoharms may be disabled. Possible values are no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698449"></a><code>tstab</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698451"></a><code>0.0 s</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698453"></a>Extra stabilization time after the onset of periodicity for independent sources.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698455"></a><code>autotstab</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698457"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698459"></a>Activates the automatic initial transient (tstab) in harmonic balance and PSS shooting. If set to yes, the simulator decides whether to run tstab and for how long. Typically, the initial length of tstab is 50 periods; however, it could be longer depending on the type of circuit and its behavior. If steady-state is reached (or nearly reached), tstab terminates early. Possible values are no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698461"></a><code>envlp_autotstab</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698463"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698465"></a>Activates the automatic initial envlp (tstabenvlp) in PSS shooting. If set to yes, the simulator decides how long to run tstabenvlp. Typically, the initial length of tstabenvlp is 50 periods; however, it could be longer depending on the type of circuit and its behavior. If steady-state is reached (or nearly reached), tstabenvlp terminates early. Possible values are no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698467"></a><code>autosteady</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698469"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698471"></a>Activates the automatic steady state detection during initial transient (tstab) in harmonic balance and PSS shooting. When steady state is reached (or nearly reached), tstab terminates early. This parameter applies only when tstab&gt;0 or when autotstab=yes. autosteady=no|0 turns this feature off; autosteady=yes|1 activates this feature; autosteady=2 runs autosteady with lower steady state tolerance than autosteady=1. autosteady=2 may help pss convergence but with higher tstab costs. Possible values are 0, 1, 2, no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698473"></a><code>tstabenvlp_autosteady</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698475"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698477"></a>Activates the automatic steady state detection during tstabenvlp in&#160;&#160;PSS shooting. When steady state is reached, tstabenvlp terminates early. This parameter applies only when tstabenvlpstop&gt;0 or when envlp_autotstab=yes. tstabenvlp_autosteady=no|0 turns this feature off; tstabenvlp_autosteady=yes|1 activates this feature; tstabenvlp_autosteady=2 runs autosteady with lower steady state tolerance than tstabenvlp_autosteady=1. tstabenvlp_autosteady=2 may help pss convergence but with higher tstabenvlp costs. Possible values are 0, 1, 2, no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698479"></a><code>tstart</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698481"></a><code>0.0 s</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698483"></a>Initial transient analysis start time.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698485"></a><code>tstabenvlpstop</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698487"></a><code>0.0 s</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698489"></a>Determines the stop time of envelope tstab.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698491"></a><code>tstabenvlpstep</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698493"></a><code>0.0 s</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698495"></a>Determines the step size of envelope tstab.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1698528"></a>Time-step parameters</p>
<table class="webflareTable" id="#id1698497">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1698499"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698505"></a><code>transres</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698507"></a><code>1e-9*stop s</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698509"></a>Transition resolution. The transient analysis attempts to stop at corners of input waveforms (for example, corners of rising/falling edge of a pulse). If such events occur within a time less than transres, the analysis combines the events into one and forces only one time point. The rest of the steps are determined by error control. This may lead to loss of detail.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698511"></a><code>maxstep</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698513"></a><code> (s)</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698515"></a>Maximum time step. The default is derived from <code>errpreset</code>.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698517"></a><code>maxacfreq</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698519"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698521"></a>Maximum frequency requested in a subsequent periodic small-signal analysis. The default is derived from <code>errpreset</code> and <code>harms</code>. This parameter is valid only for shooting.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698523"></a><code>step</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698525"></a><code>0.001*period s</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698527"></a>Minimum time step that would be used solely to maintain the aesthetics of the results. This parameter is valid only for shooting.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1698566"></a>Initial-condition parameters</p>
<table class="webflareTable" id="#id1698529">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1698531"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698537"></a><code>ic</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698539"></a><code>all</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698541"></a>The value to be used to set the initial condition. Possible values are dc, node, dev and all.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698543"></a><code>skipdc</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698545"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698547"></a>If set to yes, there is no DC analysis for initial transient. Possible values are no, yes and sigrampup.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698549"></a><code>readic</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698551"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698553"></a>File that contains initial condition.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698555"></a><code>oscic</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698557"></a><code>default</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698559"></a>Oscillator IC method. It determines how the starting values for the oscillator are calculated. <code>oscic=lin</code> provides you an accurate initial value, but it takes time; oscic=lin_ic&#39; is not recommended, which is the older version of <code>oscic=lin</code> for shooting analysis for backward compatibility;<code>oscic=fastic</code> is fast, but it is less accurate. &#39;oscic=skip&#39; directly uses the frequency provided by you as the initial guess frequency. It is only for the two-tier method. Possible values are default, lin, lin_ic, fastic and skip.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698561"></a><code>useprevic</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698563"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698565"></a>If set to yes or ns, use the converged initial condition from previous analysis as ic or ns. Possible values are no, yes and ns.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1698586"></a>Convergence parameters</p>
<table class="webflareTable" id="#id1698567">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1698569"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698575"></a><code>readns</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698577"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698579"></a>File that contains an estimate of the initial transient solution.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698581"></a><code>cmin</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698583"></a><code>0 F</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698585"></a>Minimum capacitance from each node to ground.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1698666"></a>Output parameters</p>
<table class="webflareTable" id="#id1698587">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1698589"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698595"></a><code>harmsvec</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698597"></a><code>[...]</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698599"></a>Array of desired harmonics. An alternative form of <code>harms</code> that allows selection of specific harmonics. This parameter is valid only for shooting.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698601"></a><code>outputtype</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698603"></a><code> all&#39;&#39;</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698605"></a>Output type. Possible values are all, time and freq.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698607"></a><code>save</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698609"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698611"></a>Signals to output. Possible values are all, lvl, allpub, lvlpub, selected, none and nooutput.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698613"></a><code>nestlvl</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698615"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698617"></a>Levels of subcircuits to output.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698619"></a><code>oppoint</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698621"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698623"></a>Should operating point information be computed for initial timestep; if yes, where should it be printed (screen or file). Possible values are no, screen, logfile and rawfile.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698625"></a><code>skipstart</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698627"></a><code>0 s</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698629"></a>The time to start skipping output data.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698631"></a><code>skipstop</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698633"></a><code>stop s</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698635"></a>The time to stop skipping output data.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698637"></a><code>skipcount</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698639"></a><code>1</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698641"></a>Save only one of every skipcount points.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698643"></a><code>strobeperiod</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698645"></a><code>0 s</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698647"></a>The output strobe interval (in seconds) of transient time.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698649"></a><code>strobedelay</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698651"></a><code>0 s</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698653"></a>The delay (phase shift) between the skipstart time and the first strobe point.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698655"></a><code>saveinit</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698657"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698659"></a>If set to yes, the waveforms for the initial transient before steady state are saved. Possible values are no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698661"></a><code>harmoutputlist</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698663"></a><code>[...]</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698665"></a>Array of harmonics indices for hb output.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1698710"></a>State-file parameters</p>
<table class="webflareTable" id="#id1698667">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1698669"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698675"></a><code>write</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698677"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698679"></a>File to which initial transient solution (before steady-state) is written.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698681"></a><code>writefinal</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698683"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698685"></a>File to which final transient solution in steady-state is written. This parameter is now valid only for shooting.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698687"></a><code>swapfile</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698689"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698691"></a>Temporary file to hold steady-state information. It tells Spectre to use a regular file, rather than virtual memory to hold the periodic operating point. Use this option if Spectre complains about not having enough memory to complete the analysis. This parameter is now valid only for shooting.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698693"></a><code>writepss</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698695"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698697"></a>File to which the converged steady-state solution is written. The file of shooting and HB cannot be mutually reused.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698699"></a><code>readpss</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698701"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698703"></a>File from which a previously converged steady-state solution is read. For shooting method, PSS loads the solution and checks the residue of the circuit equations only. The solution is re-used if the residue is satisfactory. Otherwise, the solution is re-converged using the finite difference method. The results from shooting QPSS cannot be used in HB QPSS analysis and vice-versa.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698705"></a><code>checkpss</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698707"></a><code>yes</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698709"></a>If set to yes, the previous PSS results (from readpss file) are checked and PSS+MIC is rerun if any condition has changed. If set to no, the simulator assumes that nothing has changed and uses the solution from the file without checking and running PSS+MIC again. This parameter is now valid only for shooting. Possible values are no and yes.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1698730"></a>Integration method parameters</p>
<table class="webflareTable" id="#id1698711">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1698713"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698719"></a><code>method</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698721"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698723"></a>Integration method. The default is derived from <code>errpreset</code>. This parameter is valid only for shooting. Possible values are euler, trap, traponly, gear2 and gear2only.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698725"></a><code>tstabmethod</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698727"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698729"></a>Integration method used in stabilization time. The default is <code>traponly</code> for autonomous circuits, or is derived from <code>errpreset</code> for driven circuits. Possible values are euler, trap, traponly, gear2 and gear2only.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1698834"></a>Accuracy parameters</p>
<table class="webflareTable" id="#id1698731">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1698733"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698739"></a><code>errpreset</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698741"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698743"></a>Selects a reasonable collection of parameter settings. Possible values are liberal, moderate and conservative.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698745"></a><code>relref</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698747"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698749"></a>Reference used for the relative convergence criteria. The default is derived from <code>errpreset</code>. Possible values are pointlocal, alllocal, sigglobal and allglobal.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698751"></a><code>lteratio</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698753"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698755"></a>Ratio used to compute LTE tolerances from Newton tolerance. The default is derived from <code>errpreset</code>.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698757"></a><code>lteminstep</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698759"></a><code>0.0 s</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698761"></a>Local truncation error is ignored if the step size is less than lteminstep.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698763"></a><code>steadyratio</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698765"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698767"></a>Ratio used to compute steady-state tolerances from LTE tolerance. The default is derived from <code>errpreset</code>.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698769"></a><code>maxperiods</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698771"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698773"></a>Maximum number of iterations allowed before convergence is reached in shooting or harmonic balance Newton iteration. For PSS and QPSS, the default is 20 for driven circuits, and 50 for oscillators; For HB, the default is 100.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698775"></a><code>max_innerkrylov_size</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698777"></a><code>20</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698779"></a>The maximum iteration number allowed in inner gmres solver in two-level gmres linear solver. The default value is 12 for large signal and 20 for small signal analysis.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698781"></a><code>max_outerkrylov_size</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698783"></a><code>4</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698785"></a>The maximum iteration number allowed in inner gmres solver in two-level gmres linear solver. The default value is 4.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698787"></a><code>itres</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698789"></a><code>1e-4 for shooting, 0.9 for HB</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698791"></a>Controls the residual for iterative solution of linearized matrix equation at each Newton iteration. Tightening the parameter can help with the Newton convergence, but does not affect the result accuracy. The value should be between [0, 1]. Default value for shooting APS flow is 1e-3.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698793"></a><code>inexactNewton</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698795"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698797"></a>Inexact Newton method. Possible values are no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698799"></a><code>finitediff</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698801"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698803"></a>Enable finite difference method refinement for driven circuits after shooting method. Possible values are no, yes and refine.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698805"></a><code>highorder</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698807"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698809"></a>Perform a high-order refinement after low-order convergence. The Multi-Interval Chebyshev polynomial spectral algorithm is used. This parameter is only valid for shooting. Possible values are no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698811"></a><code>psaratio</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698813"></a><code>1</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698815"></a>Ratio used to compute high-order polynomial spectral accuracy from Newton tolerance. This parameter is only valid for shooting.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698817"></a><code>maxorder</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698819"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698821"></a>The maximum order of the Chebyshev polynomials used in waveform approximation. Possible values are from 2 to 16. Default value is 16 for driven circuits and 12 for autonomous circuits. This parameter is valid only for shooting.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698823"></a><code>fullpssvec</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698825"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698827"></a>Use the full vector containing solutions at all PSS time steps in the linear solver. The default is derived from the size of the equation and the property of the PSS time steps. This parameter is only valid for shooting. Possible values are no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698829"></a><code>fdharms</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698831"></a><code>10</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698833"></a>Number of harmonics considered for distributed (frequency-domain) components, such as nport, delay, mtline, and delayed controlled sources. This parameter is valid only for shooting and for those components for which &#39;Fmax&#39; parameter of neither model nor instance is set.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1698956"></a>Harmonic Balance parameters</p>
<table class="webflareTable" id="#id1698835">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1698837"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698843"></a><code>harmonicbalance</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698845"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698847"></a>Use Harmonic Balance engine instead of time-domain shooting. Possible values are no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698849"></a><code>flexbalance</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698851"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698853"></a>Same parameter as <code>harmonicbalance</code>. Possible values are no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698855"></a><code>pinnode</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698857"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698859"></a>Node to pin during autonomous HB simulation.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698861"></a><code>pinnodeminus</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698863"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698865"></a>Second node to pin during autonomous HB simulation. Needed only when differential nodes exist in oscillator.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698867"></a><code>pinnoderank</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698869"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698871"></a>Harmonic rank to pin during autonomous HB simulation.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698873"></a><code>pinnodemag</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698875"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698877"></a>This parameter gives an estimate of the magnitude of the pin node voltage. Default value is 0.01.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698879"></a><code>oversamplefactor</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698881"></a><code>1</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698883"></a>Oversample device evaluations.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698885"></a><code>oversample</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698887"></a><code>[...]</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698889"></a>Array of oversample factors for each tone. This parameter overrides oversamplefactor.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698891"></a><code>oscmethod</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698893"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698895"></a>Osc Newton method for autonomous HB. Possible values are onetier and twotier.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698897"></a><code>hbhomotopy</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698899"></a><code>tone</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698901"></a>Name of Harmonic Balance homotopy selection methods. Possible values are tstab, source, gsweep, tone, inctone, aggregation and steptone.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698903"></a><code>sweepic</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698905"></a><code>none</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698907"></a>IC extrapolation method in sweep HB analysis. Possible values are none, linear and log.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698909"></a><code>gstart</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698911"></a><code>1.e-7</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698913"></a>Start conductance for hbhomotopy of gsweep.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698915"></a><code>gstop</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698917"></a><code>1.e-12</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698919"></a>Stop conductance for hbhomotopy of gsweep.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698921"></a><code>glog</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698923"></a><code>5</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698925"></a>Number of steps, log sweep for hbhomotopy of gsweep.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698927"></a><code>backtracking</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698929"></a><code>yes</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698931"></a>This parameter is used to activate the backtracking utility of Newton&#39;s method. The default is yes. Possible values are no, yes and forced.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698933"></a><code>excludeconvgwithBK</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698935"></a><code>yes</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698937"></a>Possible values are no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698939"></a><code>krylov_size</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698941"></a><code>10</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698943"></a>The minimum iteration count of the linear matrix solver used in HB large-signal analysis. After reaching krylov_size&#160;&#160;iterations, the iteration is forced to terminate because of the poor rate of convergence. Increase krylov_size if the simulation reports insufficient norm reduction errors in GMRES.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698945"></a><code>hbprecond_solver</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698947"></a><code>basicsolver</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698949"></a>Choose a linear solver for the GMRES preconditioner. Possible values are basicsolver, blocksolver, autoset, blockdense, blocksolver2 and directsolver.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698951"></a><code>lowmem</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698953"></a><code>0</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698955"></a>Harmonic balance low memory mode; Possible values are 0, 1, or number (&gt;=10). The default value is &#39;0&#39;, the low memory mode is turned off; if &#39;1&#39; is set, the standard low memory mode is turned on; If a number no less than 10 is set, Spectre interprets the value as the memory requested in GigaBytes.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1698982"></a>Annotation parameters</p>
<table class="webflareTable" id="#id1698957">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1698959"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698965"></a><code>annotate</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698967"></a><code>sweep</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698969"></a>Degree of annotation. Possible values are no, title, sweep, status, estimated, steps, iters, detailed, rejects, alliters, detailed_hb and internal_hb.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698971"></a><code>annotateic</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698973"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698975"></a>Degree of annotation for initial condition. Possible values are no, title, sweep, status, estimated, steps, iters, detailed, rejects and alliters.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698977"></a><code>title</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698979"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698981"></a>Analysis title.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1699002"></a>Newton parameters</p>
<table class="webflareTable" id="#id1698983">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1698985"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698991"></a><code>maxiters</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698993"></a><code>5</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698995"></a>Maximum number of iterations per time step.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698997"></a><code>restart</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1698999"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699001"></a>Restart the DC/PSS solution if set to &#39;yes&#39;; if set to &#39;no&#39;, reuse the previous solution as an initial guess; if set to &#39;firstonly&#39;, restart if it is the first point of sweep (supported only in HB). The default value is &#39;no&#39; for HB and &#39;yes&#39; for shooting. Possible values are no, yes and firstonly.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1699016"></a>Circuit age</p>
<table class="webflareTable" id="#id1699003">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1699005"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699011"></a><code>circuitage</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699013"></a><code> (Years)</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699015"></a>Stress time. Age of the circuit used to simulate hot-electron degradation of MOSFET and BSIM circuits.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1699060"></a>Tstab save/restart parameters</p>
<table class="webflareTable" id="#id1699017">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1699019"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699025"></a><code>saveperiod</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699027"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699029"></a>Save the tran analysis periodically on the simulation time.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699031"></a><code>saveperiodhistory</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699033"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699035"></a>Maintains the history of saved files. If yes, maintains all the saved files. Possible values are no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699037"></a><code>saveclock</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699039"></a><code> (s)</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699041"></a>Save the tran analysis periodically on the wall clock time. The default is 1800s for Spectre. This parameter is disabled in the APS mode by default.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699043"></a><code>savetime</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699045"></a><code>[...]</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699047"></a>Save the analysis states into files on the specified time points.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699049"></a><code>savefile</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699051"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699053"></a>Save the analysis states into the specified file.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699055"></a><code>recover</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699057"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699059"></a>Specify the file to be restored.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1699074"></a>Oscillator PPV parameters</p>
<table class="webflareTable" id="#id1699061">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1699063"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699069"></a><code>ppv</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699071"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699073"></a>If set to yes, save the oscillators&#39; perturbation projection vector (PPV), representing the oscillators&#39; phase sensitivity to perturbations in the voltage or current at the nodes of the oscillator. Possible values are no and yes.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1699184"></a>Compression parameters</p>
<table class="webflareTable" id="#id1699075">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1699077"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699083"></a><code>xdbcompression</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699085"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699087"></a>Sets the automatic gain compression analysis. In automatic gain compression analysis, Spectre automatically sweeps the input excitation until the gain, as defined by the analysis parameter xdbgain, compresses by the amount specified by the analysis parameter xdblevel. In gain compression analysis, Spectre outputs the hb solution at the calculated compression point only. Dependent analyses, such as hbnoise and hbac, are supported and calculated about the calculated compression level. Auxiliary output includes the gain and voltage/power compression curves. These outputs are available for analysis and post-processing in ADE. The possible values are yes and no. Default is no.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699089"></a><code>xdblevel</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699091"></a><code>[...]</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699093"></a>Sets the gain compression level for compression analysis. The reference point for gain compression is the small-signal gain of the circuits, or as specified by the analysis parameter xdbref. Default is 1.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699095"></a><code>xdbgain</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699097"></a><code>power</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699099"></a>Chooses between the voltage gain and transducer power gain as the target for compression point calculation. When xdbgain=power, the gain is defined as G (dB) = Pload (dBm) - Pavailable (dBm). When xdbgain=voltage, the gain is defined as G (dB) = dB20(|Vload|/|Vsource|). In both cases, Spectre sweeps the excitation source until xdbref - G = xdblevel, where the analysis parameter xdbref defines the reference level for compression calculation. Possible values are power and voltage. Default is power.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699101"></a><code>xdbref</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699103"></a><code>linear</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699105"></a>Sets the reference point for gain compression calculations. When xdbref=linear, spectre uses the small-signal gain as the reference. When xdbref=max, spectre uses the maximum observed gain as the reference. Possible values are linear and max. Default is linear.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699107"></a><code>xdbsource</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699109"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699111"></a>The instance name of the excitation source, which is swept automatically to reach the compression level. When xdbgain=power, the excitation source must be a port instance. When xdbgain=voltage, the excitation source must be a vsource instance.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699113"></a><code>xdbload</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699115"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699117"></a>The instance name of the load termination. When xdbgain is power, xdbload can be a port, a resistor, or a current probe.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699119"></a><code>xdbnodep</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699121"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699123"></a>The output terminals for voltage gain calculation when xdbgain=voltage. If either is left unspecified, the terminal is assumed to be the global ground.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699125"></a><code>xdbnoden</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699127"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699129"></a>The output terminals for voltage gain calculation when xdbgain=voltage. If either is left unspecified, the terminal is assumed to be the global ground.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699131"></a><code>xdbrefnode</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699133"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699135"></a>The reference node when xdbload is a current probe. The default is the ground node.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699137"></a><code>xdbharm</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699139"></a><code>[...]</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699141"></a>The Integer array which specifies the harmonic indexes of the output voltage or power component.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699143"></a><code>xdbsteps</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699145"></a><code>100</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699147"></a>The maximum number of steps for the compression point search. The simulator terminates if xdbsteps exceeds before the compression point is found. The default is 100.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699149"></a><code>xdbmax</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699151"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699153"></a>The maximum input power (or voltage) for the compression point search. Default is 30 dBm when xdbgain=power, and 2.0 V when xdbgain=voltage.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699155"></a><code>xdbstart</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699157"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699159"></a>The starting input power (or voltage) for the compression point search. Default is (xdbmax-70) dBm when xdbgain=power, and xdbmax/20000 when xdbgain=voltage.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699161"></a><code>xdbtol</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699163"></a><code>0.01</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699165"></a>Sets the tolerance for compression analysis.&#160;&#160;This tolerance is used in compression curve fitting and calculating the compression point.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699167"></a><code>xdbrapid</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699169"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699171"></a>Sets the automatic gain compression analysis in rapid mode. In this mode, Spectre does not trace the compression curve and calculates only the compression point.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699173"></a><code>xdbcpi</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699175"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699177"></a>Sets the estimated input-referred compression point for rapid compression analysis.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699179"></a><code>backoff</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699181"></a><code>0.0</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699183"></a>The backoff point. If defined, an addition harmonic balance analysis will be performed after the compression analysis is done. Default is 0 dBm when xdbgain=power, and 0 V when xdbgain=voltage.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1699198"></a>Memory estimation parameters</p>
<table class="webflareTable" id="#id1699185">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1699187"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699193"></a><code>memoryestimate</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699195"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699197"></a>Sets the memory usage estimate for Harmonic Balance. If yes, a memory estimate is printed in the log file. You can use this memory estimate to plan the computing resources before submitting harmonic balance runs. In memory estimate mode, a short simulation is performed first, and the engine exits after printing the estimate in the log file without saving any results. If no, the simulation continues after the memory estimate is printed. Memory estimation is not recommended for simulations that require less than 500MB approximately. For PSS analysis, memory estimate mode does not apply unless flexbalance=yes. memoryestimate=1 estimates the memory usage for large-signal analysis and memoryestimate=2 estimates both large-signal analysis and small-signal simulations. Possible values are no and yes.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1699242"></a>Oscillator tuning mode parameters</p>
<table class="webflareTable" id="#id1699199">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1699201"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699207"></a><code>tuneparam</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699209"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699211"></a>When set, tuneparam enables the tuning mode oscillator analysis. In the tuning mode analysis, a circuit parameter is automatically varied to reach the oscillation frequency specified by the fundfreqs parameter. The tuning parameter can be a device instance parameter (as determined by the parameters tunedev) or a netlist parameter. This mode applies only to autonomous circuits (oscillators).</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699213"></a><code>tunedev</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699215"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699217"></a>Sets the instance name of a device whose parameter (identified by tuneparam) will be varied such that the circuit oscillates at the specified frequency. Applies only in tuning mode autonomous analysis. Tunedev must be used with tuneparam.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699219"></a><code>tunerange</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699221"></a><code>[...]</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699223"></a>The tuning range of the parameter identified by tuneparam. Although tunerange is not required, it can aid in convergence if set. Tunerange also can be used with &#39;tunestep&#39; or &#39;tunelin&#39; to decide the acceptable discrete parameter set.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699225"></a><code>tunestep</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699227"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699229"></a>Specify the step size between two adjacent discrete tuning points. Must be used with &#39;tunerange&#39;.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699231"></a><code>tunelin</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699233"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699235"></a>Specify the numbers of discrete tuning points. Must be used with &#39;tunerange&#39;.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699237"></a><code>tunevalues</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699239"></a><code>[...]</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699241"></a>Specify the values of discrete tuning points.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1699280"></a>LSSP parameters</p>
<table class="webflareTable" id="#id1699243">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1699245"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699251"></a><code>lsspports</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699253"></a><code>[...]</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699255"></a>Specifies the list of ports on which the large-signal 2-port S-parameters are calculated.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699257"></a><code>lsspharms</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699259"></a><code>[...]</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699261"></a>Specifies the output harmonic for large-signal S-parameter calculations. The input harmonic is defined by the frequency parameters on the input port instance.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699263"></a><code>lsspfile</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699265"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699267"></a>Identifies the file name for large-signal S-parameter output.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699269"></a><code>lsspdatafmt</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699271"></a><code>touchtone</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699273"></a>Sets the file format of the large-signal S-parameter output. Possible values are spectre and touchstone. Default is touchstone.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699275"></a><code>lsspdatatype</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699277"></a><code>msgphase</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699279"></a>Sets the data format or the large-signal S-parameter output. Possible values are realimag, magphase and phase. Default is magphase.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1699336"></a>Dynamic parameters</p>
<table class="webflareTable" id="#id1699281">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1699283"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699289"></a><code>param</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699291"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699293"></a>Name of the parameter to be updated during pss/hb analysis (tstab stage). When param=paramName and param_vec=[t1 value1 t2 value2 ... valuen tn], paramName is set to value1 at t1, value2 at t2, and so on. Pss/hb analysis uses the last value in the param_vec(valuen) to find the steady state.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699295"></a><code>paramset</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699297"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699299"></a>Name of the dynamic parameter set.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699301"></a><code>param_vec</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699303"></a><code>[...] s</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699305"></a>The time_value points to param=name.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699307"></a><code>param_file</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699309"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699311"></a>The file that contains the time_value points to param=name.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699313"></a><code>sub</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699315"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699317"></a>Name of the subcircuit instance parameter specified in param=name.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699319"></a><code>mod</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699321"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699323"></a>Name of the device model parameter specified in param=name.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699325"></a><code>dev</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699327"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699329"></a>Name of the device instance parameter specified in param=name.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699331"></a><code>param_step</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699333"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699335"></a>Defines the frequency of updating the dynamic parameter values. If param_step=0, it updates the parameter value at a given time point.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1699368"></a>Osc macro source parameters</p>
<table class="webflareTable" id="#id1699337">
<caption style="text-align:left;"><p>
</p><pre class="webflare-courier-new codeContent">
<a id="pgfId-1699339"></a></pre></caption>
<tbody><tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699345"></a><code>oscmacrogene</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699347"></a><code>no</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699349"></a>If set to yes, harmonic balance steady-state solution is saved. Possible values are no and yes.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699351"></a><code>oscmacroprobe</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699353"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699355"></a>Specify probe of which the current data is to be saved.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699357"></a><code>oscmacroout</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699359"></a><code>[...]</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699361"></a>Specify nodes of which the voltage data is to be saved.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699363"></a><code>oscmacrosave</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699365"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1699367"></a>File to which harmonic balance steady-state solution is to be written.</p>
</td>
</tr>
</tbody></table>
<p>
<a id="pgfId-1699369"></a>The initial transient analysis provides a flexible mechanism to direct the circuit to a particular steady-state solution of interest, and to avoid undesired solutions. Another use of the initial transient simulation is to help in convergence by eliminating large but fast decaying modes that are present in many circuits. For example, in case of driven circuits, consider the reset signal in the figure below.</p>
<p>
<a id="pgfId-1699370"></a>            __    __    __    __    __    __    __    __</p>
<p>
<a id="pgfId-1699371"></a>clock _____|&#160;&#160;|__|&#160;&#160;|__|&#160;&#160;|__|&#160;&#160;|__|&#160;&#160;|__|&#160;&#160;|__|&#160;&#160;|__|&#160;&#160;|__</p>
<p>
<a id="pgfId-1699372"></a>                         __________________________________</p>
<p>
<a id="pgfId-1699373"></a>reset __________________|</p>
<p>
<a id="pgfId-1699374"></a>                               _____       _____       ____</p>
<p>
<a id="pgfId-1699375"></a>Q2&#160;&#160;  ________________________|     |_____|     |_____|</p>
<p>
<a id="pgfId-1699376"></a>               ^        ^         ^           ^</p>
<p>
<a id="pgfId-1699377"></a>         tstart|  tonset|    tinit|      tstop|</p>
<p>
<a id="pgfId-1699378"></a>                        |&lt;-tstab-&gt;|&lt;- period-&gt;|</p>
<p>
<a id="pgfId-1699379"></a>In the above figure, the initial transient analysis runs from <code>tstart</code> to <code>tstop</code>. If initial transient results&#160;&#160;are relevant, you can output them&#160;&#160;by setting <code>saveinit</code> to yes. The steady-state results are always computed for the specified <code>period</code>, from <code>tinit</code> to <code>tstop</code>. By default, <code>tstart</code> and <code>tstab</code> are set to zero, while <code>tinit</code>, <code>tonset</code> and <code>tstop</code> are always automatically generated.</p>
<p>
<a id="pgfId-1699380"></a>It happens in some circuits that the linearity of the relationship between the initial and final state depends on when the shooting or HB begins. Conceptually, when shooting or HB begins should not matter, as long as it is after the time when the stimuli have become periodic, because the periodic response repeats endlessly. However, in practice, starting at a good point can improve the convergence, and starting at a bad point can degrade the convergence and slow down the analysis. In general, it is best to try to avoid starting the shooting interval at a point where the circuit is undergoing strong nonlinear behavior. For example, when shooting is used to simulate switch-capacitor filters, it is best if <code>tinit</code> falls at the beginning of a clock transition, preferably a transition that follows a relatively long period of settling. If instead <code>tinit</code> occurred during a clock transition or soon after one, it is likely that the opamps will undergo slew-rate limiting at the start of the shooting interval, which will slow convergence. Switching mixers follow similar rules.</p>
<p>
<a id="pgfId-1699381"></a>When PSS analysis simulates oscillators, either transient or linear initialization is performed to obtain an initial guess of the steady-state solution and the oscillating frequency. Two initialization methods are implemented based on transient and linear analysis, respectively. When <code>oscic=default</code> is specified, transients initialization is used and the length of the transient is specified by <code>tstab</code>. It is necessary to start the oscillator by using initial conditions, or by using a brief impulsive stimulus, just as you would if you were simulating the turn-on transient of the oscillator using transient analysis. Initial conditions would be provided for the components of the oscillators&#39; resonator. If an impulsive stimulus is used, it should be applied so as to couple strongly into the oscillatory mode of the circuit, and poorly into any other long-lasting modes, such as those associated with bias circuitry. The Designer&#39;s Guide to Spice and Spectre [K. S. Kundert, Kluwer Academic Publishers, 1995] describes techniques for starting oscillators in some depth. When <code>oscic=default</code> is specified, <code>oscic=lin</code>, linear initialization is used. In this method, both oscillation frequency and amplitude are estimated based on linear analysis at DC solution. No impulsive stimulus or initial conditions are needed. Linear initialization is suitable for linear type of oscillators, such as LC and crystal oscillators. Note that tstab transient is still performed after linear initialization though it can be significantly shortened (or skipped in HB). Either way, specifying a non-zero <code>tstab</code> parameter can improve convergence. </p>
<p>
<a id="pgfId-1699382"></a>By default, only the time-domain results are computed in shooting. If you specify either <code>harms</code> or <code>harmsvec</code>, or set <code>outputtype</code> to <code>freq</code> or <code>all</code>, the frequency-domain results will also be computed. If frequency-domain results are requested, but the desired harmonics are not specified, its default value is 9. The time-domain output waveform generation can be inhibited by setting <code>outputtype</code> to <code>freq</code>.</p>
<p>
<a id="pgfId-1699383"></a>The accuracy of the results does not depend on the number of harmonics that are requested, but only on the accuracy parameters, which are set in the same fashion as in the transient analysis. Besides a few new parameters, like <code>steadyratio</code> and <code>maxacfreq</code>, all the others parameters work in PSS analysis in exactly the same manner as they work on transient analysis. For HB, besides <code>reltol</code>, <code>abstol</code>, <code>steadyratio</code> and <code>lteratio</code>, the number of harmonics has the most impact on the accuracy of simulation results. When too few harmonics are used, an error occurs due to the aliasing effect. To obtain accurate results, <code>harms</code> should be big enough to cover the signal bandwidth.</p>
<p>
<a id="pgfId-1699384"></a>Several parameters determine the accuracy of the PSS analysis. <code>reltol</code> and <code>abstol</code> control the accuracy of the discretized equation solution. These parameters determine how well charge is conserved and how accurately steady-state or equilibrium points are computed. You can set the integration errors in the computation of the circuit dynamics (such as time constants), relative to <code>reltol</code> and <code>abstol</code>, by setting the <code>lteratio</code> parameter. </p>
<p>
<a id="pgfId-1699385"></a>For shooting, the <code>steadyratio</code> parameter adjusts the maximum allowed mismatch in node voltages or current branches from the beginning to the end of the steady-state period. For HB, the <code>steadyratio</code> parameter adjusts the maximum allowed error in the node voltages or in the current branches of the steady-state. This value is multiplied by <code>lteratio</code> and <code>reltol</code> to determine the convergence criterion. The relative convergence norm is printed along with the actual mismatch value at the end of each iteration, indicating the progress of the steady-state iteration.</p>
<p>
<a id="pgfId-1699386"></a>For shooting, the parameter <code>maxperiods</code> controls the maximum number of shooting iterations for PSS analysis. Its default value is set to 20 for driven PSS and 50 for autonomous PSS. For HB, the parameter &#39;maxperiods&#39; controls the maximum number of HB iterations for both driven and autonomous HB analysis. Its default value is set to 100.</p>
<p>
<a id="pgfId-1699387"></a>The <code>finitediff</code> parameter allows the use of finite difference (FD) after shooting. Usually this eliminates the above mismatch in node voltages or current branches. It can also refine the grid of time steps. In some cases, numerical error of the linear solver still introduces a mismatch. You can set <code>steadyratio</code> to a smaller value to activate a tighter tolerance for the iterative linear solver. If <code>finitediff</code> is set to no, FD method is turned off. If it is set to yes, PSS applies FD method and tries to improve the beginning small time steps, if necessary. If it is set to refine, PSS applies FD method and tries to refine the time steps. When the simulation uses second-order method, uniform second-order gear is used. <code>finitediff</code> is automatically changed from no to yes when <code>readpss</code> and <code>writepss</code> are specified to re-use PSS results.</p>
<p>
<a id="pgfId-1699388"></a>The <code>maxacfreq</code> parameter is used to automatically adjust the <code>maxstep</code> and reduce errors due to aliasing in frequency-domain results. By default, the <code>maxacfreq</code> is set to four times the frequency of the largest requested harmonic, but is never set to less than forty times the fundamental.</p>
<p>
<a id="pgfId-1699389"></a>The parameter <code>relref</code> determines how the relative error is treated. The <code>relref</code> values are as follows:</p>
<p>
<a id="pgfId-1699390"></a><code>relref=pointlocal</code>: Compares the relative errors in quantities at each node to that node alone.</p>
<p>
<a id="pgfId-1699391"></a><code>relref=alllocal</code>:&#160;&#160; Compares the relative errors at each node to the largest values found for that node alone for all past time.</p>
<p>
<a id="pgfId-1699392"></a><code>relref=sigglobal</code>:&#160;&#160;Compares relative errors in each circuit signal to the maximum for all signals at any previous point in time.</p>
<p>
<a id="pgfId-1699393"></a><code>relref=allglobal</code>:&#160;&#160;Same as <code>relref=sigglobal</code>, except that it also compares the residues (KCL error) for each node to the maximum of each node&#39;s past history.</p>
<p>
<a id="pgfId-1699394"></a>The <code>errpreset</code> parameter lets you adjust the simulator parameters to fit your needs quickly. In most cases, it should also be the only parameter you need to adjust. </p>
<p>
<a id="pgfId-1699395"></a>Guidelines for using errpreset in driven circuits in shooting are as follows: </p>
<p>
<a id="pgfId-1699396"></a>If the circuit contains only one periodic tone and you are only interested in obtaining the periodic operating point, set errpreset to <code>liberal</code>. This setting provides reasonably accurate result and the fastest simulation speed. </p>
<p>
<a id="pgfId-1699397"></a>If the circuit contains more than one periodic tone and you are interested in intermodulation results, set errpreset to <code>moderate</code>. This setting provides accurate results. </p>
<p>
<a id="pgfId-1699398"></a>If you want a very low noise floor in your simulation result and accuracy is your main interest, set errpreset to <code>conservative</code>. </p>
<p>
<a id="pgfId-1699399"></a>The effect of <code>errpreset</code> on other parameters for driven circuits is shown in the following table.</p>
<p>
<a id="pgfId-1699400"></a>----------------------------------------------------------------------------</p>
<p>
<a id="pgfId-1699401"></a>     Parameter defaults and estimated numerical noise floor in simulation </p>
<p>
<a id="pgfId-1699402"></a>                      result as a function of <code>errpreset</code></p>
<p>
<a id="pgfId-1699403"></a>----------------------------------------------------------------------------</p>
<p>
<a id="pgfId-1699404"></a>errpreset&#160;&#160;  reltol  relref     method     lteratio  steadyratio  maxstep</p>
<p>
<a id="pgfId-1699405"></a>----------------------------------------------------------------------------</p>
<p>
<a id="pgfId-1699406"></a>liberal&#160;&#160;    1e-3    sigglobal  traponly   3.5       0.001        period/50</p>
<p>
<a id="pgfId-1699407"></a>moderate&#160;&#160;   1e-3    alllocal   gear2only  3.5       0.001        period/200</p>
<p>
<a id="pgfId-1699408"></a>conservative 1e-4&#160;&#160;  alllocal   gear2only  *         0.01         period/200</p>
<p>
<a id="pgfId-1699409"></a>* : lteratio=10.0 for conservative <code>errpreset</code>. Only if user-specified reltol &lt;= 1e-4 * 10.0/3.5, lteratio is set to 3.5. </p>
<p>
<a id="pgfId-1699410"></a>The new errpreset settings include a new default <code>reltol</code>, which is an enforced upper limit for appropriate setting. An increase of <code>reltol</code> above the default value is ignored by the simulator.by the simulator. You can decrease this value in the options statement. The only way to increase <code>reltol</code> is to <code>relax errpreset</code>. </p>
<p>
<a id="pgfId-1699411"></a>Estimated numerical noise floor for a weak non-linear circuit is -70dB for liberal, -90dB for moderate, and -120dB for conservative settings. For a linear circuit, the noise floor is even lower.Multi-interval Chebyshev (MIC) is activated when you explicitly set <code>highorder=yes</code>, which drops numerical noise floor by at least 30dB. MIC falls back to the original method if it encounters difficulty converging. You can tighten <code>psaratio</code> to further drop numerical noise floor. </p>
<p>
<a id="pgfId-1699412"></a>Spectre sets the value of <code>maxstep</code> so that it cannot be larger than the value given in the table.&#160;&#160;Except for <code>reltol</code> and <code>maxstep</code>, <code>errpreset</code> does not change the value of parameters that you explicitly set. The actual values used for the PSS analysis are given in the log file. If <code>errpreset</code> is not specified in the netlist, <code>liberal</code> settings is used. For HB, only <code>reltol</code> is affected by <code>errpreset</code> and the effect is the same as that in shooting. However, <code>lteratio</code> remains 3.5 and <code>steadyratio</code> remains 1 with all values of <code>errpreset</code>.</p>
<p>
<a id="pgfId-1699413"></a>Guidelines for using errpreset in autonomous circuits are as follows: </p>
<p>
<a id="pgfId-1699414"></a>If you want a fast simulation with reasonable accuracy, you can set errpreset to <code>liberal</code>. </p>
<p>
<a id="pgfId-1699415"></a>If you have some concern for accuracy, you can set errpreset to <code>moderate</code>. </p>
<p>
<a id="pgfId-1699416"></a>If accuracy is your main interest, you can set errpreset to <code>conservative</code>.</p>
<p>
<a id="pgfId-1699417"></a>The effect of <code>errpreset</code> on other parameters for autonomous circuits is shown in the following table.</p>
<p>
<a id="pgfId-1699418"></a>-------------------------------------------------------------------------------</p>
<p>
<a id="pgfId-1699419"></a>              Parameter defaults as a function of <code>errpreset</code></p>
<p>
<a id="pgfId-1699420"></a>-------------------------------------------------------------------------------</p>
<p>
<a id="pgfId-1699421"></a>errpreset&#160;&#160;  reltol  relref     method      lteratio  steadyratio  maxstep</p>
<p>
<a id="pgfId-1699422"></a>-------------------------------------------------------------------------------</p>
<p>
<a id="pgfId-1699423"></a>liberal&#160;&#160;    1e-3    sigglobal  traponly    3.5       0.001        period/50 </p>
<p>
<a id="pgfId-1699424"></a>moderate&#160;&#160;   1e-4    alllocal   gear2only   3.5       0.01         period/200</p>
<p>
<a id="pgfId-1699425"></a>conservative 1e-5&#160;&#160;  alllocal   gear2only   *         0.1          period/400</p>
<p>
<a id="pgfId-1699426"></a>* : lteratio=10.0 for conservative <code>errpreset</code> by default. Only if user-specified reltol &lt;= 1e-5*10.0/3.5, lteratio is set to 3.5. </p>
<p>
<a id="pgfId-1699427"></a>The value of <code>reltol</code> can be decreased from default in the options statement. The only way to increase <code>reltol</code> is to <code>relax errpreset</code>. Spectre sets the value of <code>maxstep</code> so that it cannot be larger than the value given in the table. Except for <code>reltol</code> and <code>maxstep</code>, <code>errpreset</code> does not change the value of any parameters you have explicitly set. The actual values used for the PSS analysis are given in the log file.If <code>errpreset</code> is not specified in the netlist, <code>liberal</code> settings will be used.Multi-interval Chebyshev (MIC) is activated when you explicitly set <code>highorder=yes</code>, which drops numerical noise floor by at least 30dB. MIC falls back to the original method if it encounters difficulty in converging. You can tighten <code>psaratio</code> to further drop numerical noise floor. </p>
<p>
<a id="pgfId-1699428"></a>A long stabilization (by specifying a large tstab) can help with PSS convergence. However, it can slow down simulation. By default, in the stabilization stage, the following settings are used: reltol=1e-3, maxstep=period/25, relref=sigglobal, and method=traponly. These settings are overwritten when maxstep, relref, or tstabmethod are specified explicitly in pss statement, or reltol is specified explicitly in options statement.</p>
<p>
<a id="pgfId-1699429"></a>If the circuit you are simulating has infinitely fast transitions (for example, a circuit that contains nodes with no capacitance), Spectre might have convergence problems. To avoid this, you must prevent the circuit from responding instantaneously. You can accomplish this by setting <code>cmin</code>, the minimum capacitance to ground at each node, to a physically reasonable nonzero value. This often significantly improves Spectre convergence.</p>
<p>
<a id="pgfId-1699430"></a>You can specify the initial condition for the transient analysis by using the <code>ic</code> statement or the <code>ic</code> parameter on the capacitors and inductors. If you do not specify the initial condition, the DC solution is used as the initial condition. The <code>ic</code> parameter on the transient analysis controls the interaction of various methods of setting the initial conditions. The effects of individual settings are as follows:</p>
<p>
<a id="pgfId-1699431"></a><code>ic=dc</code>: All initial conditions are ignored, and the DC solution is used.</p>
<p>
<a id="pgfId-1699432"></a><code>ic=node</code>: The <code>ic</code> statements are used, and the <code>ic</code> parameter on the capacitors and inductors is ignored.</p>
<p>
<a id="pgfId-1699433"></a><code>ic=dev</code>: The <code>ic</code> parameters on the capacitors and inductors are used, and the <code>ic</code> statements are ignored.</p>
<p>
<a id="pgfId-1699434"></a><code>ic=all</code>: Both <code>ic</code> statements and <code>ic</code> parameters are used, and the <code>ic</code> parameters override the <code>ic</code> statements.</p>
<p>
<a id="pgfId-1699435"></a>If you specify an initial condition file with the <code>readic</code> parameter, initial conditions from the file are used, and any <code>ic</code> statements are ignored.</p>
<p>
<a id="pgfId-1699436"></a>After you specify the initial conditions, Spectre computes the actual initial state of the circuit by performing a DC analysis. During this analysis, Spectre forces the initial conditions on nodes by using a voltage source in series with a resistor whose resistance is <code>rforce</code> (see <code>options</code>).</p>
<p>
<a id="pgfId-1699437"></a>With the <code>ic</code> statement, it is possible to specify an inconsistent initial condition (one that cannot be sustained by the reactive elements). Examples of inconsistent initial conditions include setting the voltage on a node with no path of capacitors to ground, or setting the current through a branch that is not an inductor. If you initialize Spectre inconsistently, its solution jumps, that is, it changes instantly at the beginning of the simulation interval. You should avoid such changes because Spectre can have convergence problems while trying to make the jump.</p>
<p>
<a id="pgfId-1699438"></a>You can skip DC analysis entirely by using the parameter <code>skipdc</code>. If DC analysis is skipped, the initial solution is trivial or is given in the file that you specified by using the <code>readic</code> parameter, or if the <code>readic</code> parameter is not specified, by the values specified on the ic statements. Device-based initial conditions are not used for <code>skipdc</code>. Nodes that you do not specify with the <code>ic</code> file or <code>ic</code> statements start at zero. You should not use this parameter unless you are generating a nodeset file for circuits that have trouble in the DC solution; it usually takes longer to follow the initial transient spikes that occur when the DC analysis is skipped than it takes to find the real DC solution. The <code>skipdc</code> parameter might also cause convergence problems in the transient analysis.</p>
<p>
<a id="pgfId-1699439"></a>The possible settings of parameter <code>skipdc</code> and their descriptions are as follows:</p>
<p>
<a id="pgfId-1699440"></a><code>skipdc=no</code>:&#160;&#160;       Initial solution is calculated using normal DC analysis (default). </p>
<p>
<a id="pgfId-1699441"></a><code>skipdc=yes</code>:&#160;&#160;      Initial solution is given in the file specified by the <code>readic</code> parameter or the values specified on the ic statements. </p>
<p>
<a id="pgfId-1699442"></a><code>skipdc=sigrampup</code>:&#160;&#160;Independent source values start at 0 and ramp up to their initial values in the first phase of the simulation. The waveform production in the time-varying independent source is enabled after the rampup phase.The rampup simulation is from <code>tstart</code> to time=0 s, and the main simulation is from time=0 s to <code>tstab</code>. If the <code>tstart</code> parameter is not specified,the default <code>tstart</code> time is set to -0.1*<code>tstab</code>.</p>
<p>
<a id="pgfId-1699443"></a>Nodesets help find the DC or the initial transient solution. You can specify nodesets in the circuit description file with nodeset statements or in a separate file by using the readns parameter. When nodesets are specified, Spectre computes an initial guess of the solution by performing DC analysis, while forcing the specified values on to nodes by using a voltage source in series with a resistor whose resistance is rforce. Spectre then removes these voltage sources and resistors and computes the required solution from this initial guess.</p>
<p>
<a id="pgfId-1699444"></a>Nodesets have two important uses. First, if a circuit has two or more solutions, nodesets can bias the simulator towards computing the required solution. Second, this is a convergence aid. By estimating the solution of the largest possible number of nodes, you might be able to eliminate a convergence problem or significantly speed up convergence.</p>
<p>
<a id="pgfId-1699445"></a>When you simulate the same circuit multiple times, it is recommended that you use both <code>write</code> and <code>readns</code> parameters and assign the same file name to both parameters. DC analysis then converges quickly even if the circuit has changed since the last simulation, and the nodeset file is automatically updated.</p>
<p>
<a id="pgfId-1699446"></a>Nodesets and initial conditions have similar implementation, but produce different effects. Initial conditions define the solution, whereas nodesets only influence it. When you simulate a circuit with a transient analysis, Spectre forms and solves a set of differential equations. Because differential equations have an infinite number of solutions, a complete set of initial conditions must be specified to identify the required solution. Any initial conditions that you do not specify are computed by the simulator to be consistent. The transient waveforms then start from initial conditions. Nodesets are usually used as a convergence aid and do not affect the final results. However, in a circuit with more than one solution, such as a latch, nodesets bias the simulator towards finding the solution closest to the nodeset values.</p>
<p>
<a id="pgfId-1699447"></a>The <code>method</code> parameter specifies the integration method. The possible settings and their meanings are as follows:</p>
<p>
<a id="pgfId-1699448"></a><code>method=euler</code>:&#160;&#160;    Backward-Euler is used exclusively.</p>
<p>
<a id="pgfId-1699449"></a><code>method=traponly</code>:&#160;&#160; Trapezoidal rule is used almost exclusively.</p>
<p>
<a id="pgfId-1699450"></a><code>method=trap</code>:&#160;&#160;     Backward-Euler and the trapezoidal rule are used.</p>
<p>
<a id="pgfId-1699451"></a><code>method=gear2only</code>:&#160;&#160;Gear&#39;s second-order backward-difference method is used almost exclusively.</p>
<p>
<a id="pgfId-1699452"></a><code>method=gear2</code>:&#160;&#160;    Backward-Euler and second-order Gear are used.</p>
<p>
<a id="pgfId-1699453"></a>The trapezoidal rule is usually the most efficient when you want high accuracy. This method can exhibit point-to-point ringing, but you can control this by tightening the error tolerances. For this reason, though, if you choose very loose tolerances to get a quick answer, the backward-Euler or second-order Gear will probably give better results than the trapezoidal rule. Second-order Gear and backward-Euler can make systems appear more stable than they really are. This effect is less pronounced with second-order Gear or when you request high accuracy.</p>
<p>
<a id="pgfId-1699454"></a>Spectre provides two methods for reducing the number of output data points saved: <code>strobing</code>, based on the simulation time, and <code>skipping</code> time points, which saves only every N&#39;th point. </p>
<p>
<a id="pgfId-1699455"></a>The parameters <code>strobeperiod</code> and <code>strobedelay</code> control the strobing method.<code>strobeperiod</code> sets the interval between the points that you want to save, and <code>strobedelay</code> sets the offset within the period relative to <code>skipstart</code>. The simulator forces a time step on each point to be saved, so that the data is computed, and not interpolated. </p>
<p>
<a id="pgfId-1699456"></a>The skipping method is controlled by <code>skipcount</code>. If this is set to N, only every N&#39;th point is saved.</p>
<p>
<a id="pgfId-1699457"></a>The parameters <code>skipstart</code> and <code>skipstop</code> apply to both data reduction methods. Before <code>skipstart</code> and after <code>skipstop</code>, Spectre saves all computed data. </p>
<p>
<a id="pgfId-1699458"></a>With parameter &#39;hbhomotopy&#39;, you can specify harmonic balance homotopy selection methods. The possible values of parameter &#39;hbhomotopy&#39; and their descriptions are as follows:</p>
<p>
<a id="pgfId-1699459"></a>&#39;hbhomotopy=tstab&#39;: Simulator runs a transient analysis and generates an initial guess for harmonic balance analysis; it is recommended for nonlinear circuits or circuits with frequency dividers.</p>
<p>
<a id="pgfId-1699460"></a>&#39;hbhomotopy=source&#39;: For driven circuit, the simulator ignores tstab and accordingly increases the source power level; for oscillators, the simulator accordingly adjusts the probe magnitude until the probe has no effect on the oscillators. It is recommended for strongly nonlinear or high Q circuits.</p>
<p>
<a id="pgfId-1699461"></a>&#39;hbhomotopy=tone&#39;: This method is valid only for multi-tone circuit. The simulator first solves a single-tone circuit by turning off all the tones, except the first one, and then solves the multi-tone circuit by restoring all the tones and using the single-tone solution as its initial guess. It is recommended for multi-tone simulation with a strong first tone.</p>
<p>
<a id="pgfId-1699462"></a>&#39;hbhomotopy=inctone&#39;: Simulator first solves a single tone, then turns on moderate tones incrementally till all tones are enabled. It is recommended for circuits with one strong large tone.</p>
<p>
<a id="pgfId-1699463"></a>&#39;hbhomotopy=gsweep&#39;: A resistor, whose conductance is g, is connected with each node, and the sweep of g is controlled by gstart, gstop, and glog. It is recommended for circuits containing high-impedance or quasi-floating nodes.</p>
<p>
<a id="pgfId-1699464"></a> </p>

<br /><a href="#pagetop">Return to top</a><br /></div>
<!-- Begin Buttons --><!-- End Buttons -->
<footer><nav class="navigation"><b><em><a href="chap3_re_Periodic_S-Parameter_Analysis_psp.html" id="prev" title="Periodic S-Parameter Analysis (psp)">Periodic S-Parameter Analysis  ...</a></em></b><b><em><a href="chap3_re_Periodic_STB_Analysis_pstb.html" id="nex" title="Periodic STB Analysis (pstb)">Periodic STB Analysis (pstb)</a></em></b></nav><div>
            For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2023, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved. 
          </div></footer>
 

 <div id="cad_image_modal" style="background-color: rgba(0, 0, 0, 0.6);"><center id="cad_image_modal_center">&#160; </center><span style="margin-right:50px;margin-top:100px;font-weight:bold;font-size:20px;background:#e5e5e5;border:1px solid #e5e5e5;border-radius:25px;height:30px;width:20px;padding-left:6px;padding-top:2px;color: black;" onclick="document.querySelector('#cad_image_modal').classList.remove('opac');">X</span></div> 

</body></html>