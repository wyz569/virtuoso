
<html><head><title>Technology Data Preparation</title>
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="leenap" />
<meta name="CreateDate" content="2023-07-12" />
<meta name="CreateTime" content="1689152497" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="" />
<meta name="DocTitle" content="Mixed Signal (MS) Interoperability Guide" />
<meta name="DocType" content="Methodology" />
<meta name="FileTitle" content="Technology Data Preparation" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="prod_feature" content="" />
<meta name="prod_subfeature" content="" />
<meta name="new_topic" content="" />
<meta name="spotlight_topic" content="" />
<meta name="FileType" content="Chapter" />
<meta name="Keyword" content="dmsflow" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2023-07-12" />
<meta name="ModifiedTime" content="1689152497" />
<meta name="NextFile" content="Design_Data_Preparation.html" />
<meta name="Group" content="" />
<meta name="Platform" content="Custom IC Design,Digital IC Design," />
<meta name="PrevFile" content="Overview_of_Mixed_Signal_Interoperability.html" />
<meta name="c_product" content="Virtuoso Layout Suite,Innovus," />
<meta name="Product" content="Virtuoso Layout Suite,Innovus," />
<meta name="ProductFamily" content="Virtuoso Layout Suite,Innovus," />
<meta name="ProductVersion" content="22.13" />
<meta name="RightsManagement" content="Copyright 2023 Cadence Design Systems Inc." />
<meta name="Title" content="Mixed Signal (MS) Interoperability Guide -- Technology Data Preparation" />
<meta name="Version" content="22.13" />
<meta name="Renderer" content="WIKI" />
<meta name="SpaceKey" content="dmsflow221" />
<meta name="confluence-version" content="7.4.1" />
<meta name="ecms-plugin-version" content="04.20.001" />

        
        <link href="styles/site.css" rel="stylesheet" type="text/css" />
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
    

    
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    document.querySelectorAll("img").forEach((img, index) => {
   img.addEventListener("click", (e) => { 
    document.querySelector("#cad_image_modal").classList.add("opac");
      document.querySelector("#cad_image_modal_center").innerHTML = `<img style="position:absolute;top:0;bottom:0;left:0;right:0; margin: auto;max-height: 96%;max-width: 96%;" src="${e.target.src}">`;});});});
</script>

<style>
 img{cursor:pointer;
 }
 #cad_image_modal{
 position:fixed;left:0;top:0;width:100%;background:#00000099;overflow:hidden;height:0;opacity:0;transition: height 0ms 1s, opacity 1s 0ms;
 }
 #cad_image_modal.opac{height: 100%;opacity: 1;transition: height 0ms 0ms, opacity 1s 0ms;
 }
 #cad_image_modal span{
  position:fixed;right:10px;top:10px;cursor:pointer;color:#fff;
 }
 </style>

</head><body style="background-color: #FFFFFF;"><!-- Begin Buttons --><header xmlns:html="http://www.w3.org/1999/xhtml"><div class="docHeadr">Product Documentation<img src="images/Cadence-Logo.jpg" /></div>
<nav class="blueHead"><ul><li><a class="content" href="dmsflowTOC.html">Contents</a></li><li><a class="prev" href="Overview_of_Mixed_Signal_Interoperability.html" title="Overview_of_Mixed_Signal_Interoperability">Overview_of_Mixed_Signal_Inter ...</a></li><li style="float: right;"><a class="viewPrint" href="dmsflow.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="Design_Data_Preparation.html" title="Design_Data_Preparation">Design_Data_Preparation</a></li></ul></nav></header><!-- End Buttons --><div xmlns:html="http://www.w3.org/1999/xhtml" style="font-size:14px;line-height:1.42857142857;margin:20px 0 0 0;font-weight:bold;"><center>Mixed Signal (MS) Interoperability Guide<br />Product Version 22.13, Last Updated in July 2023</center></div>
<div xmlns:html="http://www.w3.org/1999/xhtml" style="margin-left:5%;">
<p></p>

<p></p>
<div id="main-header">
                    
                    
                                                <div style="width: 100%; font-size: 32px; text-align: left;               font-weight: bold;">3</div>
<h1 style="margin: 4px 0 4px;"><span>Technology Data Preparation</span></h1>

                    
                </div>
<div class="wiki-content group" id="main-content">
                    
<p></p>
<div class="toc-macro rbtoc1689152472303">
<ul class="toc-indentation">
<li><a href="#TechnologyDataPreparation-SoftwareRequirements">Software Requirements</a></li>
<li><a href="#TechnologyDataPreparation-TechnologyDataPreparation">Technology Data Preparation</a>
<ul class="toc-indentation">
<li><a href="#TechnologyDataPreparation-LibraryandTechnologyRequirements">Library and Technology Requirements</a></li>
<li><a href="#TechnologyDataPreparation-PreparingtheTechnologyLibrary">Preparing the Technology Library</a></li>
<li><a href="#TechnologyDataPreparation-DeterminingWhetherYourMSOAPDKIsTraditionalorRapid">Determining Whether Your MSOA PDK Is Traditional or Rapid</a></li>
<li><a href="#TechnologyDataPreparation-PreparingtheIPLibrary">Preparing the IP Library</a></li>
<li><a href="#TechnologyDataPreparation-CreatingaRapidMSOAPDKwithMultiplefoundry_innovusConstraintGroups">Creating a Rapid MSOA PDK with Multiple foundry_innovus Constraint Groups</a></li>
<li><a href="#TechnologyDataPreparation-PreparingaTechnologyLibrarywithMultipleLDRSs">Preparing a Technology Library with Multiple LDRSs</a></li>
<li><a href="#TechnologyDataPreparation-RapidPDKASCIITechfileStructure">Rapid PDK ASCII Techfile Structure</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="TechnologyDataPreparation-SoftwareRequirements"><span class="cad-head-number">3.1 </span>Software Requirements</h2>

<p>The following installations &#160;are required to build the flow. There are older versions of Innovus and Virtuoso which have also been qualified for the mixed-signal flow.&#160;</p>
<ul><li>Innovus Implementation System 17.1 or later with IC 6.1.6 ISR6 &#160;or later</li></ul><h2 id="TechnologyDataPreparation-TechnologyDataPreparation"><span class="cad-head-number">3.2 </span>Technology Data Preparation</h2>

<p>This section contains the following:</p>
<ul><li><a href="#TechnologyDataPreparation-LibTechReq">Library and Technology Requirements</a></li><li><a href="#TechnologyDataPreparation-TechLibPrep">Preparing the Technology Library</a></li><li><a href="#TechnologyDataPreparation-commonPDK">Preparing the IP Library</a></li><li><a href="#TechnologyDataPreparation-MultipleLDRS">Preparing a Technology Library with Multiple LDRSs</a></li></ul>
<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-LibTechReq"></span></p>
<h3 id="TechnologyDataPreparation-LibraryandTechnologyRequirements"><span class="cad-head-number">3.2.1 </span>Library and Technology Requirements</h3>
<ul><li>Technology and IP data on OpenAccess 2.2 Data Model 4 format</li><li>A common (interoperable) Process Design Kit (PDK), which will have all the necessary technology information for Innovus and Virtuoso. For instruction on how to create a common PDK, please refer to the&#160;<a href="#TechnologyDataPreparation-TechLibPrep">Preparing the Technology Library</a>&#160;section. &#160;</li></ul><ul><li>Liberty timing library for standard cells and IP blocks and chip-level SDC file. If you do not have Liberty files and the chip-level SDC file, it will not be possible to perform static timing analysis of the top-level design.</li></ul><ul><li>Extended FE capacitance table and QRC technology file to support extraction in Innovus.</li></ul><ul><li>Power analysis libraries for enabling VoltageStorm analysis in Innovus.</li></ul>
<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-TechLibPrep"></span></p>
<h3 id="TechnologyDataPreparation-PreparingtheTechnologyLibrary"><span class="cad-head-number">3.2.2 </span>Preparing the Technology Library</h3>

<p>Historically, most digital designs have relied on the use of a LEF file to specify the required technology information for the complete implementation of the design. These LEF technology files typically contain a complete set of rules for the metal and cut layers, and a very small subset of rules on the masterslice layers:&#160;<code>poly</code>,&#160;<code>well</code>, and&#160;<code>diffusion</code>.</p>

<p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" data-base-url="https://rdwiki.cadence.com" data-image-src="attachments/425955847/425955849.png" data-linked-resource-container-id="425955847" data-linked-resource-container-version="15" data-linked-resource-content-type="image/png" data-linked-resource-default-alias="TechLib1.PNG" data-linked-resource-id="425955849" data-linked-resource-type="attachment" data-linked-resource-version="2" data-unresolved-comment-count="0" src="attachments/425955847/425955849.png" width="640" /></span></p>

<p>The use of the OpenAccess-based interoperable mixed-signal flow requires the implementation of a common OpenAccess Process Design Kit (MSOA PDK). The MSOA PDK&#160;contains the information typically found in a base PDK in addition to that found in the technology LEF. The base PDK, which is the PDK used for Virtuoso, is expected to have at least the foundry rules for the masterslice layers and will typically include the foundry rules for all the metal and cut layers. The LEF would have unique information not present in the PDK: Routing-specific information, such as default routing rules for most nets and non-default rules for selected nets. Default and non-default rules must include the list of valid routing layers and vias. The LEF language requires that routing pitch and width should be included. The LEF file also has antenna checking rules and current density limits, which could be defined in the PDK but is typically not found in a base PDK.</p>

<p>The following diagram shows the desired structure that must be built using the custom IC PDK and the digital implementation library shown above.&#160;</p>

<p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" data-base-url="https://rdwiki.cadence.com" data-image-src="attachments/425955847/425955850.png" data-linked-resource-container-id="425955847" data-linked-resource-container-version="15" data-linked-resource-content-type="image/png" data-linked-resource-default-alias="TechLib4.PNG" data-linked-resource-id="425955850" data-linked-resource-type="attachment" data-linked-resource-version="1" data-unresolved-comment-count="0" src="attachments/425955847/425955850.png" /></span></p>

<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-commonPDK"></span></p>
<h4 id="TechnologyDataPreparation-ImplementinganInteroperable/MSOAPDK"><span class="cad-head-number">3.2.2.1 </span>Implementing an Interoperable/MSOA PDK</h4>

<p>As previously mentioned, interoperable PDKs are required to take advantage of OpenAccess-based interoperability for mixed signal designs. Starting from the 18.1 release of Innovus, you now have multiple options for creating an MSOA PDK:</p>
<ul><li>Rapid MSOA PDK (Available in 18.1 and later releases)</li><li>Traditional MSOA PDK (Available prior to 18.1 and described above, these MSOA PDKs are supported only for 28nm and older nodes. If you are implementing a new MSOA PDK, Cadence recommends the implementation of a Rapid MSOA PDK.)</li><li>Innovus-only MSOA PDK (Useful for experimenting with Innovus in the OpenAccess mode)</li></ul>
<p>As discussed earlier, the process of creating an MSOA PDK involves populating the tech file used by Virtuoso (base tech) with specific information that is typically only found in a tech LEF (used for the P&amp;R environment).</p>

<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-RapidPDK"></span></p>
<h5 id="TechnologyDataPreparation-ImplementingaRapidMSOAPDK">Implementing a Rapid MSOA PDK</h5>
<p>This is the easiest method for creating an MSOA PDK that could be used by Innovus and Virtuoso to implement mixed signal designs. The Rapid MSOA infrastructure removes the necessity for all DRC rules to be consistent between tech LEF and Virtuoso tech for a certain process. In other words, there is no need to change the Virtuoso tech file to align the DRC rules in it with those found in the tech LEF. Virtuoso obtains all the DRC rules from the base tech (the same tech used by Virtuoso in the past), while Innovus gets DRC rules from an ITDB layer that contains all the rules found in the tech LEF.</p>

<p>The main difference between the traditional MSOA PDK and the rapid MSOA PDK is the presence of a new foundry group in the incremental tech file, which will be used exclusively by Innovus for DRC rules.</p>

<p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" data-base-url="https://rdwiki.cadence.com" data-image-src="attachments/425955847/425955850.png" data-linked-resource-container-id="425955847" data-linked-resource-container-version="15" data-linked-resource-content-type="image/png" data-linked-resource-default-alias="TechLib4.PNG" data-linked-resource-id="425955850" data-linked-resource-type="attachment" data-linked-resource-version="1" data-unresolved-comment-count="0" src="attachments/425955847/425955850.png" /></span></p>

<p>The table below provide guidelines on the use of rapid MSOA PDKs:</p>
<div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col /><col /><col /></colgroup><tbody><tr><th class="confluenceTh"><br /></th><th class="confluenceTh">
<p><strong>Rapid</strong></p>
</th><th class="confluenceTh">
<p><strong>Traditional**</strong></p>
</th></tr>
<tr><td class="confluenceTd">
<p>Same as LEF from an Innovus point of view?</p>
</td>
<td class="confluenceTd">
<p>Yes</p>
</td>
<td class="confluenceTd">
<p>Yes</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p>Cellviews are interoperable with Virtuoso?</p>
</td>
<td class="confluenceTd">
<p>Yes</p>
</td>
<td class="confluenceTd">
<p>Yes</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p>OpenAccess tech supports Design Rule Driven (DRD) design and <br />Virtuoso Space-based Router (VSR) with the same rules as LEF?</p>
</td>
<td class="confluenceTd">
<p>No</p>
</td>
<td class="confluenceTd">
<p>Yes</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p>Target processes?</p>
</td>
<td class="confluenceTd">
<p>New process nodes that are often changing</p>
</td>
<td class="confluenceTd">
<p>Process nodes that are stable</p>
</td>
</tr>
<tr><td class="confluenceTd">
<p>User who is expected to create the PDK?</p>
</td>
<td class="confluenceTd">
<p>End users who receive frequent LEF updates<br />from their library vendor</p>
</td>
<td class="confluenceTd">
<p>Library vendors</p>
</td>
</tr>
</tbody></table></div>

<p>**Traditional MSOA PDKs are covered in detail in the next section.</p>

<p>You can follow the steps outlined below to implement a rapid MSOA PDK:</p>

<p><span class="fontdefaultcadence"><ol><li>Read LEF into Innovus using&#160;<code>init_design</code>:<br /><ul><li>A dummy/empty Verilog netlist can be used for this step</li><li>Dump out canonical LEF files using&#160;<code>write_lef_library -tech_only</code>&#160;and&#160;<code>-macro_only</code></li><li>Files created:&#160;<code>TECH.lef</code>&#160;and&#160;<code>MACRO.lef</code></li></ul><code>set init_lef_file { &lt;<em>list_of_lef_files</em>&gt; }</code><br /><code>set init_verilog {<em>list_of_verilog_files_or_dummy</em>}<br />set init_top_cell &lt;<em>top_cell_name</em>&gt;</code><br /><code>init_design</code><br /><code>write_lef_library -tech_only TECH.lef</code><br /><code>write_lef_library -macro_only MACRO.lef</code></li><li>Determine if the&#160;<code>LAYER</code>/<code>CUTCLASS</code>/<code>NDR</code>&#160;names in the LEF are consistent with those in the base PDK. If not, use&#160;<code>sed</code>&#160;to create temp LEF file(s) that align to the&#160;<code>LAYER</code>/<code>CUTCLASS</code>/<code>NDR</code>&#160;names in the base PDK.&#160;<br /><strong>Note:</strong>&#160;Details and examples for this step are provided later in this document.</li><li>Use&#160;<code>lef2oa -useFoundryInnovus</code>&#160;to process the&#160;<code>TECH.lef</code>&#160;(or the version created through the optional&#160;<code>sed</code>&#160;step).<br />
<p>If Step 2 was not required, you can use the following command:<br /><code>lef2oa -useFoundryInnovus -lef TECH.lef -lib RapidPDK -techRefs BasePDK</code><br />If you had to use&#160;<code>sed</code>&#160;to rename certain items in Step 2, use the following command (here, the&#160;<code>TECH_OA_NAMES.lef</code>&#160;has been created using&#160;<code>sed</code>):<br /><code>lef2oa -useFoundryInnovus -lef TECH_OA_NAMES.lef -lib RapidPDK -techRefs BasePDK</code></p>
</li><li>
<p>Use&#160;<code>lef2oa</code>&#160;to process the&#160;<code>MACRO.lef</code>:<br /><code>lef2oa -lef MACRO.lef -lib RapidPDK</code>&#160;(If&#160;<code>sed</code>&#160;was not used)&#160;<br /><code>lef2oa -lef MACRO_OA_NAMES.lef -lib RapidPDK</code>&#160;(If&#160;<code>sed</code>&#160;was used)<br />While importing the standard cell LEFs, ensure that the standard cells library does not have any existing cells with the same names. <code>lef2oa</code> cannot override physical data in the standard cell abstract views by default, so you might see the following message:<br /><code>WARNING: (OALEFDEF-50057): stdcell.lef (107464-107522) : MACRO XXXXXX: The macro attempts to redefine obstructions, but updating physical data is not supported. The new obstructions were ignored. Use the -overwrite option to create the designs from scratch.</code><br /><span>If you want to recreate the abstracts for these cells, y</span>ou need use either the <code>-overwrite</code> option of <code>lef2oa</code> or delete the cellview for these cells. However, note that it is possible to import the antenna information for an existing cell from a different LEF file by using <code>lef2oa</code>.<br /><span>In some process nodes, the standard cells that are electrically equivalent (EEQ) come in multiple macro LEF files. For example, the </span><code>macroB.lef</code><span> file has a </span><code>OR_SIZE1A_H100</code><span> standard cell that has the following EEQ statement:</span><br /><code>EQ OR_SIZE1_H100 ;<br /></code><span>while the cell </span><code>OR_SIZE1_H100</code><span> is in the </span><code>macroA.lef</code><span> file.</span><br /><span>To convert these macro LEFs into abstract, concatenate the two macro LEF files and then use </span><code>lef2oa</code><span> to read the concatenated file:</span><br /><code>cat macroA.lef macroB.lef &gt; macroAB.lef</code><br /><code>lef2oa -lef macroAB.lef -lib RapidPDK</code><span> (If </span><code>sed</code><span> was not used)</span><br /><span>Otherwise, if you use </span><code>lef2oa</code><span> to convert the </span><code>macroB.lef</code><span> file directly (</span><code>lef2oa -lef macroB.lef -lib RapidPDK</code><span>), </span><code>lef2oa</code><span> will fail and issue the following message when reading </span><code>macroB.lef</code><span>:</span><br /><code>ERROR: (OALEFDEF-50055): macroB(74-75) : MACRO OR_SIZE1A_H100: The macro requires that the EEQ master cell OR_SIZE1_H100 be defined before macro use. This attribute was ignored.</code></p>
</li><li>Read the OpenAccess library data (from Steps 3 and 4) into Innovus by using&#160;<code>init_design</code>:<br /><ul><li>A dummy/empty Verilog netlist can be used for this step</li><li>Dump out canonical LEF files using&#160;<code>write_lef_library -tech_only</code>&#160;and&#160;<code>-macro_only</code></li><li>Files created:&#160;<code>TECH_RapidPDK.lef</code>&#160;and&#160;<code>MACRO_RapidPDK.lef</code></li></ul><code>set init_oa_ref_lib { RapidPDK }</code><br /><code>set init_verilog { &lt;<em>list_of_verilog_files_or_dummy</em>&gt; }<br />set init_top_cell &lt;<em>top_cell_name</em>&gt;<br /></code><code>init_design</code><br /><code>write_lef_library -tech_only TECH_RapidPDK.lef</code><br /><code>write_lef_library -macro_only MACRO_RapidPDK.lef</code></li><li>
<p>Compare the LEF files from Step 5 against the ones from Step 1 or 2. The only differences should be that additional layers from the base PDK that were not in the original LEF will be present:</p>
<ul><li>
<p>If Step 2 was required, compare to the files from that step instead of Step 1. Use:<br /><code>diff TECH.lef TECH_RapidPDK.lef &gt; TECH_RapidPDK.diff</code><br /><code>diff MACRO.lef MACRO_RapidPDK.lef &gt; MACRO_RapidPDK.diff</code></p>
</li><li>If Step 2 was required, use:<br /><code>diff TECH_OA_NAMES.lef TECH_RapidPDK.lef &gt; TECH_RapidPDK.diff</code><br /><code>diff MACRO_OA_NAMES.lef MACRO_RapidPDK.lef &gt; MACRO_RapidPDK.diff</code></li></ul>
<p>Except the additional layers from the base PDK, there should be no differences, which indicates that Innovus should be able to produce identical results as compared to the flows using the the original LEFs.</p>
</li></ol></span></p>

<p><span style="letter-spacing: 0.0px;">As you can see, Steps 1-4 are for creating the rapid PDK, and Steps 5 and 6 are for checking the rapid PDK.</span></p>

<p><u>Details of Step 2 (using&#160;<code>sed</code>&#160;to create temp LEF file(s) that align to the&#160;<code>LAYER</code>/<code>CUTCLASS</code>/<code>NDR</code>&#160;names in the base PDK)</u>:</p>

<p>Simple&#160;<code>sed</code>&#160;syntax is used to make sure that only complete names are mapped. For example,&#160;<code>M1</code>&#160;should be mapped to&#160;<code>METAL1</code>, but&#160;<code>CM1</code>&#160;should not be affected by that mapping. The&#160;<code>sed</code>&#160;approach relies on the white space separated style that is used by the LEF/DEF syntax. It maps any complete name, so it will affect the names inside the property string values as well.</p>

<p>There are some limitation to the use of&#160;<code>sed</code>:</p>
<ul><li>If the LEF file contains names that need to be mapped that are also keywords, then extra processing is required.&#160;<br />Example: Mapping a layer called&#160;<code>PWELL</code>&#160;to&#160;<code>PW</code>&#160;would affect the&#160;<code>TYPE PWELL</code>&#160;as well.</li><li>If the LEF and OpenAccess names are overlapping in some way:<br />Example 1: LEF has&#160;<code>M0</code>,&#160;<code>M1</code>,&#160;<code>M2</code>, ...,&#160;<code>M8</code>&#160;and OpenAccess has layers&#160;<code>M1</code>,&#160;<code>M2</code>,&#160;<code>M3</code>...,&#160;<code>M9<br /></code>To handle this case, the order of statements in the&#160;<code>sed</code>&#160;file is important to prevent the layer&#160;<code>M0</code>&#160;from becoming&#160;<code>M1</code>, then&#160;<code>M2</code>, then&#160;<code>M3</code>, and so on, as the&#160;<code>sed</code>&#160;file is processed (which happens sequentially). This is an unlikely perverse case, but is still easy to handle.<br /><br />Example 2: LEF has CUTCLASS names&#160;<code>SQ</code>&#160;and&#160;<code>RE</code>, while the respective names in OpenAccess are&#160;<code>VSINGLECUT</code>&#160;and&#160;<code>VDOUBLECUT</code>. In addition,&#160;LEF has layers&#160;<code>M1</code>&#160;and&#160;<code>VIA1</code>, while the respective OpenAccess layers are called&#160;<code>METAL1</code>&#160;and&#160;<code>VIA12</code>&#160;as shown in the example below.&#160;</li></ul>
<p>Example:</p>

<p><code>s/\&lt;M1\&gt;/METAL1/g</code><br /><code>s/\&lt;VIA1\&gt;/VIA12/g</code><br /><code>s/\&lt;RE\&gt;/VDOUBLECUT/g</code><br /><code>s/\&lt;SQ\&gt;/VSINGLECUT/g</code></p>

<p>In this case, the following syntax shoud be used:</p>

<p><code>s/\&lt;<em>lef_name</em>\&gt;/<em>oa_name</em>/g</code></p>

<p>The&#160;<code>\&lt;</code>&#160;and&#160;<code>\&gt;</code>&#160;are used to prevent partial matching.</p>

<p>To additionally handle the case where layer&#160;<code>PWELL</code>&#160;needs to be mapped to&#160;<code>PW</code>, the following syntax is required:</p>

<p>(<code><em>lef_names_to_oa_names</em>.sed</code>)</p>

<p><code>s/\&lt;TYPE PWELL\&gt;/TYPE PWELL_temp/g</code></p>

<p><code>s/\&lt;PWELL\&gt;/PW/g</code></p>

<p><code>s/\&lt;M1\&gt;/METAL1/g</code></p>

<p><code>s/\&lt;VIA1\&gt;/VIA12/g</code></p>

<p><code>s/\&lt;RE\&gt;/VDOUBLECUT/g</code></p>

<p><code>s/\&lt;SQ\&gt;/VSINGLECUT/g</code></p>

<p><code>s/\&lt;TYPE PWELL_temp\&gt;/TYPE PWELL/g</code></p>

<p>Using&#160;<code>sed</code>&#160;to map OpenAccess names to LEF names:</p>

<p>To additionally handle the case where layer&#160;<code>PW OR</code>&#160;needs to be mapped to&#160;<code>PWELL</code>&#160;in LEF, the following syntax is required:</p>

<p>(oa_names_to_lef_names.sed)</p>

<p><code><em>s/\&lt;TYPE PWELL_temp\&gt;/TYPE PWELL/g</em></code></p>

<p><code>s/\&lt;PW\&gt;/PWELL/g</code></p>

<p><code>s/\&lt;METAL1\&gt;/M1/g</code></p>

<p><code>s/\&lt;VIA12\&gt;/VIA1/g</code></p>

<p><code>s/\&lt;VDOUBLECUT\&gt;/RE/G</code></p>

<p><code>s/\&lt;VSINGLECUT\&gt;/SQ/g</code></p>

<p><code><em>s/\&lt;TYPE PWELL_temp\&gt;/TYPE PWELL/g</em></code></p>

<p>The lines in Italic font are not actually required because the reverse mapping does not have the collision in this specific case.</p>

<p>The following are not covered by&#160;<code>sed</code>-based mapping:</p>
<ul><li>Special case mapping for LEF and OpenAccess semantic differences, such as:<ul><li>LEF&#160;<code>CM1 MASK1</code>&#160;becoming&#160;<code>CM1A</code>&#160;in OpenAccess</li><li><code>R1</code>&#160;(region layer) handling</li><li><code>*_P48</code>&#160;marker layer support</li></ul>Existing OpenAccess/OAX support is still required for these (OALAYERMAP techParam, and so on)</li><li>There is no scriptable workaround for the case where the same&#160;<code>CUTCLASS</code>&#160;name is used for different layers, but the OpenAccess side has different names for each layer. The names need to be manually synced up in this case.</li></ul><h5 id="TechnologyDataPreparation-CreatingaTraditionalMSOAPDK">Creating a Traditional MSOA PDK</h5>
<p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" data-base-url="https://rdwiki.cadence.com" data-image-src="attachments/425955847/425955852.png" data-linked-resource-container-id="425955847" data-linked-resource-container-version="15" data-linked-resource-content-type="image/png" data-linked-resource-default-alias="TechLib2.PNG" data-linked-resource-id="425955852" data-linked-resource-type="attachment" data-linked-resource-version="1" data-unresolved-comment-count="0" src="attachments/425955847/425955852.png" /></span></p>

<p>In the traditional MSOA architecture, the base library contains all the rules and constraints required to run the Virtuoso implementation environment. The same DRC rules will be used by Innovus, when it uses this technology library. An incremental technology library is created, which contains only the information needed to run the place and route (P&amp;R) environment, such as any custom vias, the LefDefaultRouteSpec (LDRS) and the LefSpecialRouteSpec(LSRS), and the site definition for standard cells in the library. In order to run the P&amp;R environment, Innovus uses abstracts of the standard cells. The standard cell OpenAccess abstracts are the additional incremental technology layer in the library.</p>

<p>Given that Innovus and Virtuoso will obtain technology information from the &quot;Base tech&quot; in the above diagram, there might be a need to reconcile any difference between the tech LEF and the tech DB prior to building the library illustrated above. The resulting MSOA PDK is referred to as a &#8220;Traditional MSOA PDK&#8221;.&#160;</p>

<p>It is recommended that you seek assistance from Cadence when creating MSOA PDKs for use in the Mixed Signal flow. The PDK factory team at Cadence is available to provide assistance and answer any questions you might have in creating and testing such PDKs. The process for creating traditional MSOA PDKs differs slightly based on the technology node for which the MSOA PDK is being implemented.</p>
<h6 id="TechnologyDataPreparation-CreatingatraditionalMSOAPDKforprocessnodes40nmorolder">Creating a traditional MSOA PDK for process nodes 40nm or older</h6>
<p>The process of creating a traditional MSOA PDK involves transferring data from the tech LEF and the Virtuoso tech to the MSOA PDK by following the arrows in the diagram below:</p>

<p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" data-base-url="https://rdwiki.cadence.com" data-image-src="attachments/425955847/425955851.png" data-linked-resource-container-id="425955847" data-linked-resource-container-version="15" data-linked-resource-content-type="image/png" data-linked-resource-default-alias="TechLib3.PNG" data-linked-resource-id="425955851" data-linked-resource-type="attachment" data-linked-resource-version="1" data-unresolved-comment-count="0" src="attachments/425955847/425955851.png" width="640" /></span></p>

<p>The numbers in the above diagram represent the sequence of actions needed to implement the traditional MSOA PDK.</p>

<p>For the above process to work well, you might be required to make updates to the following items in the Virtuoso technology file to reconcile any differences between the tech LEF and the Virtuoso tech file: Layer name and purposes, LPPs, capacitance and resistance information, current density information (if existing in Virtuoso tech), and advanced routing constraints. This is denoted as Step 1 and Step 1a in the above diagram.</p>

<p>Note that many foundries have started delivering Virtuoso tech files that are ready to go through Steps 2 and 3. You should contact the particular foundry to ask for an Innovus-ready Virtuoso tech file.</p>

<p>This method uses the&#160;<code>lef2oa</code>&#160;command in the Innovus hierarchy, and is targeted only at process nodes 40nm or older. Following is an example of how this command can be used to create an MSOA PDK:</p>

<p><code>lef2oa -lef&#160; &lt;<em>name_of_the_LEF_technology_file</em>&gt; -lib &lt;<em>the_MSOA_PDK_to_be_created</em>&gt;&#160; -techRefs &lt;<em>the_base_PDK</em>&gt; -pnrLibDataOnly</code></p>

<p>The above step extracts routing information, such as metal pitch, site definition, NDRs, vias, and so on, from the tech LEF and populates the information in the resulting MSOA PDK. In the diagram above, it is represented as Step 2.</p>

<p>Now you need to create an Incremental Technology Database (ITDB) structure for the standard cells and any macro libraries to be used with the MSOA PDK. This is also done using the&#160;<code>lef2oa</code>&#160;command as shown below:</p>

<p><code>lef2oa -lib&#160; &lt;<em>the_OA_stdcell_lib_to_be_created</em>&gt; -lef&#160; stdcell.lef&#160; -techRefs&#160; &lt;<em>the_MSOA_PDK_created_from_the_previous_step</em>&gt;</code></p>

<p><code>lef2oa -lib &lt;<em>the_marco_library_to_be_created</em>&gt; -lef&#160; macro/lef -techRefs &lt;<em>the_MSOA_PDK_created_from_the_previous_step</em>&gt;</code></p>
<h6 id="TechnologyDataPreparation-CreatingatraditionalMSOAPDKforprocessnodes28nmandbelow">Creating a traditional MSOA PDK for process nodes 28nm and below</h6>
<p>The second method is to be used for 28nm and below. It involves the use of the&#160;<code><a href="../innovusTCR/write_oa_techfile.html">write_oa_techfile</a></code>&#160;command in Innovus to dump out an equivalent OpenAccess representation of the technology information found in the LEF technology file:</p>

<p><code>write_oa_techfile&#160; &lt;<em>filename</em>&gt;</code></p>

<p>After that is done, you can manually add the LEF information to the existing base PDK.</p>

<p>It is common to see a particular foundry update their existing 40nm or older LEF technology files to include rules that are typically found in newer processes. Pay special attention to warning and error messages when using the&#160;<code>lef2oa</code>&#160;command. If messages such as the one below are reported, you are advised to use the&#160;<code>write_oa_techfile</code>&#160;method to implement your interoperable MSOA PDK.</p>

<p><code>INFO: (OALEFDEF-XXXX): &lt;path to the LEF file&gt;(&lt;line numbers in the LEF file&gt;): A LEF58 property named &#39;XXXXXX&#39; with value &#39;yyyy ;&#39; was found in this line range. This property syntax is not supported by the LEF parser. This property string is kept, but is not converted into an OA rule constraint.</code></p>

<p>As can be seen from the above message, there will be a loss in the translation process to bring in the particular LEF information into the OpenAccess PDK.</p>

<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-InnMSOA"></span></p>
<h5 id="TechnologyDataPreparation-CreatinganInnovus-onlyMSOAPDK">Creating an Innovus-only MSOA PDK</h5>
<p>Very often, users who have previously used Innovus in the LEF/DEF mode wish to try running the tool in the OpenAccess mode to better understand how the data is stored when Innovus is run in the OpenAccess mode. When Innovus is run in OpenAccess, the difference in the flow is basically in the initialization steps of the flow; the actual flow scripts that go through all the steps in the flow are identical to the LEF/DEF flow. In the OpenAccess mode, Innovus saves the data for the design into the same lib/cell/view structure that is used by Virtuoso to save the design data. This provides the end user with a unique interoperable environment, where a particular cell view could be opened in either Virtuoso or Innovus, edited, and the edits made available to the other tool.</p>

<p>If the end user is not interested in interoperating the design data between Innovus and Virtuoso and would only like to run Innovus in the OpenAccess mode, the MSOA interoperable PDK could be created using only the tech LEF data.</p>

<p>The detailed process for implementing an MSOA PDK for use only by Innovus is as follows:</p>
<ol><li>
<p>Invoke EDI or Innovus with any design that uses the LEF technology information in which you are interested. Then, invoke&#160;<code>write_oa_techfile</code>.&#160;This command writes out a DFII style ASCII technology file that can later be given to the&#160;<code>techLoadDump</code>&#160;executable to create an equivalent OpenAccess technology database.</p>
</li><li>
<p>In the same EDI/Innovus session, run the following command:&#160;<br /><code>write_lef_library -tech_only</code><br />This command creates a LEF file that contains only the LEF technology information. This file will be used in later tasks in this process.</p>
</li><li>In the same EDI/Innovus session, run the following command:&#160;<br /><code>write_lef_library -macro_only</code><br />This command will write out the LEF information for macros in the LEF library. This information will get used by later tasks in this process.</li><li>
<p>The next command is available in the Virtuoso hierarchy. Ensure that you have access to the installation you want to use for this step. Invoke the following command with the file created from Step 1:<br /><code>techLoadDump -l -createLib &lt;<em>library_name</em>&gt; &lt;<em>tech_file_from_Step1</em>&gt;</code>.&#160;<br />This command will create an OA library with LEF layers and foundry rules, from the ASCII technology file that was created by the&#160;<code>write_oa_techfile</code>&#160;command.&#160;<br /><strong>Note:</strong>&#160;For advanced node processes (14nm and below), the&#160;<code>techLoadDump</code>&#160;utility from a Virtuoso Advanced Node (ICADV*) Release must be used.</p>
<div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>You can use the <code>techLoadDump</code> command from the UNIX prompt for both loading or dumping a technology library.&#160;</p>

<p><code>$ which techLoadDump</code><br /><code>/INSTALL/IC618ISR/tools/dfII/bin/techLoadDump</code></p>

<p><code>$ techLoadDump</code><br /><code>Virtuoso Framework License (111) was checked out successfully. Total checkout time was 0.09s.</code><br /><code>Usage: techLoadDump [ -l | -d ] [-createLib [-libPath libPath]] techLibName techFileName</code></p>

<p><span style=""><span>For creating a technology library, use the <code>-l</code>&#160;parameter.</span></span></p>

<p><span style=""><span>For dumping a techlib, use the <code>-d</code>&#160;parameter.</span></span></p>

<p><span style=""><span>You can also load or dump a tech file for a given library&#160;</span>by using the <em style="text-align: left;">Tools -&gt;&#160;Technology File Manager&#160;</em>command from </span>CIW in Virtuoso. This opens the Techology File Manager form, which provides options to load or dump a technology file.</p>
</div>
</div>
</li><li>The next command is available in the EDI/Innovus installation hierarchy. You will be using the output of Step 2 as input for this command. Invoke:<br /><code>lef2oa -pnrLibDataOnly -lef&#160;<em>&lt;file_from_Step2&gt;&#160;</em>-techRefs&#160;<em>&lt;library_created_from_Step4&gt;</em>&#160;-lib&#160;<em>&lt;library_name&gt;</em></code>.&#160;<br />This command maps only library-specific place and route information to an&#160;incremental tech, ignoring foundry rules. The&#160;incremental technology database references a technology database that has complete&#160;foundry information. LEF constructs DIRECTION and PITCH, along with WIDTH, OFFSET, and WIREEXTENSION (if specified) are mapped to constraints in the&#160;<code>LEFDefaultRouteSpec</code>&#160;(LDRS) type constraint group. VIAS and VIARULES defined are&#160;added to the validRoutingVias constraint in the&#160;<code>LEFDefaultRouteSpec</code>. NONDEFAULTRULES are mapped to OpenAccess constraint groups, SITES&#160;are mapped to oaSiteDefs, and MACROS are mapped to abstract oaDesigns. For more information on this command, refer to the&#160;<em>Innovus Text Command Reference</em>&#160;manual.&#160;</li><li>Now that the library has all the rules, the abstracts need to be added to the library to complete the process. In EDI/Innovus, invoke the following command:&#160;<br /><code>lef2oa -lef&#160;<em>&lt;file_from_step3&gt;</em>&#160;-lib&#160;<em>&lt;library_created_in_Step5&gt;</em></code></li></ol><h4 id="TechnologyDataPreparation-RecommendedMethodforCheckingtheIntegrityoftheCommon/InteroperablePDKforInnovus"><span class="cad-head-number">3.2.2.2 </span>Recommended Method for Checking the Integrity of the Common/Interoperable PDK for Innovus</h4>

<p>After you have implemented an interoperable PDK, it is recommended that you perform the following steps to ensure that the LEF technology related information contained in the PDK is the same as the information contained in the initial LEF file that was used to create the interoperable PDK. The verification method involves writing the LEF related information out of the PDK and comparing it to the initial LEF. The steps are as follows:</p>
<ol><li>Start Innovus with the interoperable OA PDK, which contains the LEF technology information.</li><li>Use the Innovus command&#160;<code>write_lef_library</code>&#160;to output a LEF file from the interoperable OA PDK. Note that this command outputs a LEF directly from the Innovus DB, and is an exact representation of how the LEF technology data is seen by Innovus.</li><li>Start Innovus again with the original LEF that was used to make the interoperable PDK.</li><li>Use the Innovus command&#160;<code>write_lef_library</code>&#160;to output a LEF file.</li><li>As the output of&#160;<code>write_lef_library</code>&#160;is in a&#160;canonical&#160;format, you can now use the Unix command&#160;<code>tkdiff</code>&#160;to compare the two.</li></ol>
<p>You can also dump out the PDK technology into an ASCII file from Virtuoso to check if all the rules names and values are defined correctly in the appropriate sections. This will enable you to check the mapping of the rules from the LEF file to their corresponding OpenAccess structure. To do so:</p>
<ol><li>In the Virtuoso Command Interpreter Window (CIW), choose&#160;<em>Tools</em>&#160;-&gt;&#160;<em>Technology File Manager</em>&#160;-&gt;&#160;<em>Dump</em>.</li><li>From the&#160;<em>Technology Library</em>&#160;drop-down list, select the interoperable PDK and then select the&#160;<em>Select All</em>&#160;check box to indicate you want to dump out all rules.&#160;</li><li>Specify a name for the file in the&#160;<em>ASCII Technology File</em>&#160;text box and click&#160;<em>OK</em>.</li></ol>
<p>For more information on the ASCII techfile syntax and the Rapid PDK ASCII syntax in particular, refer to the&#160;<a href="#TechnologyDataPreparation-RapidTech">Rapid PDK ASCII Techfile Structure</a>&#160;section.</p>

<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-iplib"></span></p>
<h3 id="TechnologyDataPreparation-DeterminingWhetherYourMSOAPDKIsTraditionalorRapid"><span class="cad-head-number">3.2.3 </span>Determining Whether Your MSOA PDK Is Traditional or Rapid</h3>

<p>The Innovus command <code>report_oa_lib</code> can be used to determine the type of MSOA PDK technology library being used in the Innovus session.</p>

<p><code>innovus&gt; report_oa_lib &lt;<em>libName</em>&gt;</code></p>

<p>The output of this command will be similar to the following:</p>

<p><code>Library Name        : FEOAreflib

cdsinto.tag exists     : No

Compression Level      : 0

<strong>Rapid PDK : Yes</strong>

Constraint Groups      : 6
 Library Name: FEOAreflib
  LEFDefaultRouteSpec (LEFDefaultRouteSpec, default)
   validLayers: M1 M2 M3 M4 M5 M6 AP 
   validVias: VIAGEN12 VIAGEN23 VIAGEN34 VIAGEN45 

  minSpacing
  minNumCut
  minProtrusionNumCut
  oaMinViaSpacing_FEOAreflib
  LEFSpecialRouteSpec

Technology Graph:
 FEOAreflib</code></p>

<p>If the MSOA PDK is a Rapid MSOA PDK, the report will contain the following line:</p>

<p><code>Rapid PDK&#160;&#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160;&#160;&#160; : Yes</code></p>

<p>On the other hand, if the MSOA PDK you are using is traditional, the report will contain the following line:</p>

<p><code>Rapid PDK : No</code></p>
<h3 id="TechnologyDataPreparation-PreparingtheIPLibrary"><span class="cad-head-number">3.2.4 </span>Preparing the IP Library</h3>
<ol><li>
<p>For opening a design in Innovus, ensure that the IP library contains the abstract views of all IP blocks used at the top level in the design.&#160;</p>

<p><span class="fontredcadence">
<p>While opening an existing OpenAccess design database, Innovus uses the&#160;<code>init_oa_ref_lib</code>&#160;list and the&#160;<code>init_abstract_view</code>&#160;variable values given in the configuration file to read the existing abstract view.</p>
</span></p>
</li><li>If the&#160;<code>SYMMETRY</code>&#160;attribute is not set, you can set the symmetry of a cell using the following SKILL commands in the CIW window of Virtuoso XL:<ul><li><code>cv = geGetWindowCellView(hiGetCurrentWindow())</code></li><li><code>dbSetCellViewSymmetry(cv &quot;XYR90&quot;)</code></li><li><code>dbGetCellViewSymmetry(cv)</code><code><br /></code></li></ul></li><li>If you require the analog property, add the analog property&#160;<code>oacSigTypeAnalog</code>&#160;on analog nets so that Innovus maintains such nets as&#160;<code>dbIsAnalog&#160;true</code>. This is an optional step.&#160;<br />To add the analog property (signal type) in Virtuoso, follow these steps:<ol><li>Right-click the top-most toolbar to invoke the Navigator and the Property Editor.</li><li>Expand Navigator Nets to view all the nets.</li><li>Select the net for which you want to change the signal type.</li><li>Save the design.</li></ol></li><li>To generate abstracts for analog IPs that are finally used by Innovus, use Virtuoso Abstract Generator. Virtuoso Abstract Generator preserves the&#160;<code>oacSigTypeAnalog</code>&#160;on terminal nets in the OpenAccess database.&#160;</li><li>Save the OpenAccess database of IP abstracts to be used by the digital toolsets. Use verilogAnnotate, a stand-alone UNIX utility, to annotate the bus terminal list and order the distributed terms in the physical abstract. The verilogAnnotate utility can be found in the Virtuoso installation hierarchy.&#160;<br />Run the following command:<br /><code>verilogAnnotate -refLibs &lt;&gt; -verilog &lt;&gt;</code><br />If using Virtuoso Layout XL, use the following settings instead of the&#160;<code>verilogAnnotate</code>&#160;command:<br /><code>envSetVal(&quot;layoutXL&quot; &quot;createImplicitBusTerminals&quot; &#39;boolen t)&#160;</code><br />When you create abstracts in Virtuoso Abstract Generator, use:<br /><code>absSetOption( &quot;AnnotateBusInAbstract&quot; &quot;true&quot;)&#160;</code><br />Use&#160;<code>verilogAnnotate</code>&#160;only if you have some legacy IPs that cannot not be modified by any other way.&#160;</li><li>Unset the environment variable&#160;<code>OA_HOME</code>. Ensure that the&#160;<code>OA_HOME</code>&#160;environment variable is not set before running Virtuoso XL/GXL or Innovus. Source the Virtuoso path setting file so that you can get Virtuoso XL/GXL in your&#160;<code>PATH</code>&#160;environment variable.</li><li><span class="confluence-anchor-link" id="TechnologyDataPreparation-pcell"></span>Follow these steps to open the design with parameterized cell (PCell) in Virtuoso XL/GXL, and regenerate the PCell cache:<ol><li>Choose&#160;<em>Tools-Express Pcell Manager</em>.</li><li>Enter the details and enable caching of&#160;<em>Pcell</em>&#160;check box using the&#160;<em>Auto Save</em>&#160;option.</li><li>Click&#160;<em>Save Copy</em>&#160;to save the PCell layout cache.<br />This step enables interoperation of data between Innovus and Virtuoso platforms. Close the layout window and purge your data from Virtuoso so that the Virtuoso file lock is released.&#160;For more information, see the&#160;<em>Virtuoso XL/GXL User Guide</em>.</li></ol></li></ol><h3 id="TechnologyDataPreparation-CreatingaRapidMSOAPDKwithMultiplefoundry_innovusConstraintGroups"><span class="cad-head-number">3.2.5 </span>Creating a Rapid MSOA PDK with Multiple foundry_innovus Constraint Groups</h3>

<p>A foundry may release multiple tech LEF files corresponding to the same Virtuoso PDK. In the past, you had to create a Rapid MSOA PDK for each tech LEF. The MSOA PDK creation process has been enhanced in 21.13 release of Innovus to allow for the creation of a single Rapid MSOA PDK, containing multiple&#160;<code>foundry_innovus</code> constraint groups, each corresponding to a tech LEF.&#160;</p>
<div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>This process is not recommended if the tech LEF files have any of the following conditions:</p>
<ul><li><span>Different siteDefs with the same name exist in the tech LEF files.</span></li><li><span>Vias with the same name, but different geometries, exist in the tech LEFs.</span></li><li><span>LEF NDRs with the same name, but different width, spacing, or other attributes, exist in the tech LEFs.</span></li><li><span>Cut classes with the same name, but different sizes, exist in the tech LEFs.</span></li></ul></div>
</div>

<p>The process for creating such a Rapid MSOA PDK is as follows:</p>
<ol><li>Create the base technology library, if it does not already exist, from the base ASCII tech file using either the Technology File Manager in Virtuoso or the&#160;<code>techLoadDump</code> executable. Refer to the <a href="#TechnologyDataPreparation-InnMSOA">Creating an Innovus-only MSOA PDK</a> section for details of this process.</li><li>Run the following&#160;<code>lef2oa</code> commands to create a multi-tech Rapid PDK from <code>techLEF_6</code> and <code>techLEF_9</code>.&#160;This step can be extended to any number of LEF files.<ol><li><code>lef2oa -lef techLEF_6.lef -lib myfoundry_innovus -techRefs myfoundry -logFile lef2oa_run1.log -useFoundryInnovus -suffix _6</code><br />This first&#160;<code>lef2oa</code> command uses&#160;<code>-techRefs</code> to reference the base PDK; any subsequent <code>lef2oa</code> runs do not need the&#160;<code>-techRefs</code> option. The above&#160;<code>lef2oa</code>&#160;command creates the first&#160;<code>foundry_innovus</code> constraint group with the name&#160;<code>foundry_innovus_6</code>.</li><li><code>lef2oa -lef techLEF_9.lef -lib myfoundry_innovus -logFile lef2oa_run2.log -useFoundryInnovus -suffix _9<br /></code>The above&#160;<code>lef2oa</code>&#160;command creates a second&#160;<code>foundry_innovus</code> constraint group with the name&#160;<code>foundry_innovus_9</code>. This constraint group&#160;<span>corresponds to <code>techLEF_9</code>.</span><br /><br />The previous two steps create a Rapid PDK <code>myfoundry_innovus</code>, which has the respective constraint groups named with the specified suffix <code>foundry_innovus_6</code>,<code> foundry_innovus_9</code>, <code>LEFDefaultRouteSpec_6</code> and so on.</li></ol></li><li>
<p>Convert the standard-cell and macro LEFs to OpenAccess while referencing to the Rapid PDK created in the above step. For more details on this step, see the <a href="#TechnologyDataPreparation-RapidPDK">Implementing a Rapid MSOA PDK</a> section.</p>
</li><li>Set the following commands in Innovus to read the corresponding tech from the multi-tech Rapid PDK. For example, to read&#160;<code>foundry_innovus_6</code> from the Rapid MSOA PDK, set the following commands while importing the design into Innovus. Similarly, for&#160;<code>foundry_innovus_9</code>, replace <code>_6</code> with the&#160;<code>_9</code>.&#160;<ol><li><code>set init_oa_default_rule LEFDefaultRouteSpec_6</code></li><li><code>set init_oa_foundry_rule foundry_innovus_6</code></li><li><code>set init_oa_special_rule LEFSpecialRouteSpec_6</code></li></ol></li><li>Check the library with <code>report_oa_lib</code> to make sure that you can see all the&#160;<code>foundry_innovus</code> constraint groups that needed to be created.</li><li>Validate using the <code>write_lef_library</code> output to check if the corresponding technology information is read correctly.</li></ol><div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p><span style="">While creating a multi-tech Rapid MSOA PDK, the<span>&#160;</span></span><span style="">ITDB<span>&#160;</span></span><span style="">may have multiple cut classes, not all of which will be required for a single tech set. Starting from the 21.17 release, a&#160;new constraint<span>&#160;</span></span><code>cutClassNames</code><span style=""><span>&#160;</span>is added in each<span>&#160;</span></span><code>foundry_innovus_&lt;<em>suffix</em>&gt;</code><span style=""><span>&#160;</span>to store the sizes of the cutClasses needed for a specific layer. Only the cutClasses specified in this constraint will be read into Innovus.</span></p>
</div>
</div>

<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-MultipleLDRS"></span></p>
<h3 id="TechnologyDataPreparation-PreparingaTechnologyLibrarywithMultipleLDRSs"><span class="cad-head-number">3.2.6 </span>Preparing a Technology Library with Multiple LDRSs</h3>
<div class="confluence-information-macro confluence-information-macro-note"><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"></span><div class="confluence-information-macro-body">
<p>This process will work only for a traditional MSOA PDK. You should not follow these instructions if the MSOA PDK being created is a Rapid MSOA PDK.</p>
</div>
</div>

<p>As previously discussed in this document, a LEFDefaultRouteSpec (LDRS) is a constraint group that gets added to the Virtuoso tech file for use by Place and Route tools, such as the Virtuoso Space Based Router, the Innovus Placement Engine, and the Innovus Router NanoRoute. The LDRS contains the same information as that can be found in a tech LEF file. The LDRS can contain information on routing layers, default vias, pitch, routing direction and width, layer offset, and wire extension rule. The rest of the rules are read from the foundry constraint group in the tech.&#160;</p>

<p>In some cases, you may wish to have one tech file with multiple LDRSs. For example, you may want certain designs to use different widths or routing directions for optimal results while all other designs follow the regular LDRS. In this case, the original LDRS and the modified LDRS could both exist in the tech file. When the tech file is used with Innovus, you can instruct Innovus to pick the correct LDRS by using the following setting:&#160;&#160;</p>

<p><code>init_oa_default_rule&#160; &#160; <em>ruleName&#160;</em></code></p>

<p>Note that the second LDRS should be given a unique name because that is what tells Innovus which LDRS to choose for a particular Innovus session. The tech file needs to be edited to add the second LDRS. If the contents of the tech file is dumped to ASCII, the LDRS will look similar to this example:</p>

<p><code>;********************************</code><br /><code>; CONSTRAINT GROUPS</code><br /><code>;********************************</code><br /><code>constraintGroups(</code></p>

<p><code>;( group [override] [definition] [operator] )</code><br /><code> ;( ----- ---------- ------------ ---------- )</code><br /><code> ( &quot;LEFSpecialRouteSpec&quot;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;nil&#160; &#160; &#160; &#160; &#160; &#160;&quot;LEFSpecialRouteSpec&quot;</code></p>

<p><code>interconnect(</code><br /><code> ( validVias (M2_M1 M3_M2 M4_M3 M5_M4 M6_M5 M7_M6 M8_M7 M9_M8 M10_M9 M11_M10 ) )</code><br /><code> ) ;interconnect</code><br /><code> ) ;LEFSpecialRouteSpec</code></p>

<p><code>;( group [override] [definition] [operator] )</code><br /><code> ;( ----- ---------- ------------ ---------- )</code><br /><code> ( <strong>&quot;LEFDefaultRouteSpec&quot;&#160; &#160; &#160; &#160; &#160; &#160; &#160;nil&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &quot;LEFDefaultRouteSpec&quot;</strong></code></p>

<p><code>routingDirections(</code><br /><code> ( Poly &quot;none&quot; )</code><br /><code> ( Metal1 &quot;horizontal&quot; )</code><br /><code> ( Metal2 &quot;vertical&quot; )</code><br /><code> ( Metal3 &quot;horizontal&quot; )</code><br /><code> ( Metal4 &quot;vertical&quot; )</code><br /><code> ( Metal5 &quot;horizontal&quot; )</code><br /><code> ( Metal6 &quot;vertical&quot; )</code><br /><code> ( Metal7 &quot;horizontal&quot; )</code><br /><code> ( Metal8 &quot;vertical&quot; )</code><br /><code> ( Metal9 &quot;horizontal&quot; )</code><br /><code> ( Metal10 &quot;vertical&quot; )</code><br /><code> ( Metal11 &quot;horizontal&quot; )</code><br /><code> ) ;routingDirections</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Cont&quot; 0.06 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal1&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal1&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal1&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal1&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal1&quot; 0.06 )</code><br /><code> ( minWidth &quot;Via1&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal2&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal2&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal2&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal2&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal2&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via2&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal3&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal3&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal3&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal3&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal3&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via3&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal4&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal4&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal4&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal4&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal4&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via4&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal5&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal5&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal5&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal5&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal5&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via5&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal6&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal6&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal6&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal6&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal6&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via6&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal7&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal7&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal7&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal7&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal7&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via7&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal8&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal8&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal8&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal8&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal8&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via8&quot; 0.07 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal9&quot; 0.2 )</code><br /><code> ( verticalPitch &quot;Metal9&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal9&quot; 0.1 )</code><br /><code> ( verticalOffset &quot;Metal9&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal9&quot; 0.08 )</code><br /><code> ( minWidth &quot;Via9&quot; 0.18 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal10&quot; 0.5 )</code><br /><code> ( verticalPitch &quot;Metal10&quot; 0.19 )</code><br /><code> ( horizontalOffset &quot;Metal10&quot; 0.6 )</code><br /><code> ( verticalOffset &quot;Metal10&quot; 0.095 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal10&quot; 0.22 )</code><br /><code> ( minWidth &quot;Via10&quot; 0.18 )</code><br /><code> ) ;spacings</code></p>

<p><code>routingGrids(</code><br /><code> ( horizontalPitch &quot;Metal11&quot; 0.5 )</code><br /><code> ( verticalPitch &quot;Metal11&quot; 0.475 )</code><br /><code> ( horizontalOffset &quot;Metal11&quot; 0.6 )</code><br /><code> ( verticalOffset &quot;Metal11&quot; 0.57 )</code><br /><code> ) ;routingGrids</code></p>

<p><code>spacings(</code><br /><code> ( minWidth &quot;Metal11&quot; 0.22 )</code><br /><code> ) ;spacings</code></p>

<p><code>interconnect(</code><br /><code> ( validLayers (Metal1 Metal2 Metal3 Metal4 Metal5 Metal6 Metal7 Metal8 Metal9 Metal10 Metal11 ) )</code><br /><code> ( validVias (M2_M1_HV M2_M1_VV M2_M1_VH M2_M1_HH M2_M1_2x1_HV_E M2_M1_2x1_HV_W M2_M1_1x2_HV_N M2_M1_1x2_HV_S M3_M2_VH M3_M2_HH M3_M2_HV M3_M2_VV M3_M2_M_NH M3_M2_M_SH M3_M2_2x1_VH_E M3_M2_2x1_VH_W M3_M2_1x2_VH_N M3_M2_1x2_VH_S M4_M3_HV&#160; ) )</code><br /><code> ) ;interconnect</code><br /><code> ) ;LEFDefaultRouteSpec</code><br /><code>) ;constraintGroups</code></p>

<p>If the user wishes to add a second LDRS, the ASCII tech file needs to be edited to include the name of the additional LDRS and any specific data that is typically found in the LDRS. In the example below, <code>LEFDefaultRouteSpec_3H</code> is a new LDRS added to an existing tech that already contains a default LDRS.</p>

<p><code>;********************************</code><br /><code>; CONSTRAINT GROUPS</code><br /><code>;********************************</code><br /><code>constraintGroups(</code></p>

<p><code>;( group [override] [definition] [operator] )</code><br /><code> ;( ----- ---------- ------------ ---------- )</code><br /><code> ( <strong>&quot;</strong>LEFSpecialRouteSpec&quot;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; nil&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &quot;LEFSpecialRouteSpec&quot;</code></p>

<p><code>interconnect(</code><br /><code> ( validVias (M2_M1 M3_M2 M4_M3 M5_M4 M6_M5 M7_M6 M8_M7 M9_M8 M10_M9 M11_M10 ) )</code><br /><code> ) ;interconnect</code><br /><code> ) ;LEFSpecialRouteSpec</code></p>

<p><code>;( group [override] [definition] [operator] )</code><br /><code> ;( ----- ---------- ------------ ---------- )</code><br /><code> ( <strong>&quot;LEFDefaultRouteSpec&quot;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; nil&#160; &#160; &#160; &#160; &#160; &#160; &#160; &quot;LEFDefaultRouteSpec&quot;</strong></code></p>

<p><code>.</code></p>

<p><code>.</code></p>

<p><code>.</code></p>

<p><code>..</code></p>

<p><code>&#160; ) ;LEFDefaultRouteSpec</code></p>

<p><br /></p>

<p><code>( <strong>&quot;LEFDefaultRouteSpec_3H&quot;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; nil&#160; &#160;</strong> &#160; &#160; &#160; &#160; &#160;&#160;</code></p>

<p><code>.</code></p>

<p><code>.</code></p>

<p><code>.</code></p>

<p><code>&#160; ) ;LEFDefaultRouteSpec_3H</code></p>

<p>Note that the second LDRS (<code>LEFDefaultRouteSpec_3H</code>) did not need to be defined as a LEFDefaultRouteSpec, as Innovus will search the tech for the name specified using the following command:</p>

<p><code>init_oa_default_rule&#160; <strong>LEFDefaultRouteSpec_3H</strong></code></p>

<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-RapidTech"></span></p>
<h3 id="TechnologyDataPreparation-RapidPDKASCIITechfileStructure"><span class="cad-head-number">3.2.7 </span>Rapid PDK ASCII Techfile Structure</h3>

<p>The basic sections of the ASCII technology file are mentioned below. The Rapid PDK will not have all the sections defined fully as it will create only&#160;the technology data from the LEF and use basic data, such as layer names, from the base PDK.</p>
<ul><li><code>controls</code>: This section has the general information for the PDK, such as the grid and technology reference libraries, along with the parameters that can be used across the technology library.</li><li><code>layerDefinitions</code>: This section has the user-defined layer and purpose definitions along with the display setup. Most of the layer definitions are part of the base PDK.</li><li><code>layerRules</code>: This section contains the layers function, the routing direction, the cutClasses and so on among other attributes for user-defined layers. The layer function is defined in the base PDK, but the cutClasses are defined in both the base and the Rapid PDK.</li><li><code>viaDefs</code>: This section contains all the standard and custom via definitions. Both the base and the Rapid PDK can have their own via definitions.</li><li><code>constraintGroups</code>: This section stores most of the technology rules for the layers. While Virtuoso reads in most of the technology rules from the&#160;<code>foundry</code>&#160;section in the base PDK, the Rapid PDK creates the&#160;<code>foundry_innovus</code>&#160;section, which has most of the LEF technology rules to be read in by Innovus.&#160;</li><li><code>siteDefs</code>: This section has the site definitions for the PDK. The sites can be defined in either the base or Rapid PDK.</li></ul>
<p>Click&#160;<strong><a href="#TechnologyDataPreparation-Tskeleton">here</a></strong>&#160;to&#160;view a sample of an ASCII techfile skeleton.</p>
<h4 id="TechnologyDataPreparation-KeySubsectionsintheRapidPDKASCIITechnologyfile"><span class="cad-head-number">3.2.7.1 </span>Key Subsections in the Rapid PDK ASCII Technology file</h4>

<p>The primary sections mentioned above have various subsections to manage the information easily.&#160;Let&#39;s look at some of the key subsections in the Rapid PDK ASCII technology file in more detail.</p>
<ul><li>
<p>The&#160;<code>refTechLibs</code>&#160;subsection in the&#160;<code>controls</code>&#160;section:&#160;The name of the reference technology library of the Rapid PDK is seen in the&#160;<code>refTechLibs</code>&#160;subsection of the&#160;<code>controls</code>&#160;section. This subsection contains the name of the base PDK that is being referred by the Rapid PDK. All the layer names, layer functions, and display patterns for the layer purpose pairs are picked up from this base PDK.&#160;Example:</p>
</li></ul><p style="margin-left: 60.0px;"><code>refTechLibs(</code><br /><code>;&#160;<em>techLibName</em></code><br /><code>; ---------</code><br /><code>&#160;&quot;<em>basePDKName</em>&quot;</code><br /><code>) ;refTechLibs</code></p>
<ul><li>
<p>The&#160;<code>LEFDefaultRouteSpec</code>&#160;constraint group in the&#160;<code>constraintGroups</code>&#160;section:&#160;This constraint group captures the plance-and-route (PnR) information, such as specific information on the valid routing layers and the default via definitions needed by Innovus. The valid vias can also have the standard via definitions which can be used by Innouvs to create the required variants. This section also has the following technology rules specific to these PnR layers:</p>
<ul><li>
<p>Layer direction for the routing layers. The routing direction can also be pre-defined in the base PDK in the&#160;<code>routingDirections</code>&#160;subsection of the&#160;<code>layerRules</code>&#160;section.</p>
</li><li>
<p>The minWidth for the routing layers</p>
</li><li>
<p>The routing pitch for the routing layers</p>
</li><li>
<p>The routing offset for the routing layers</p>
</li><li>
<p>The wire extension for the routing layers</p>
</li><li>
<p>The width and pitch for the 45-degree angle style routing</p>
</li></ul>
<p>Here&#39;s an example of the&#160;<code>LEFDefaultRouteSpec</code>&#160;constraint group in the&#160;<code>constraintGroups</code>&#160;section:</p>
<pre>constraintGroups(<br />;( group [override]     [definition]     [operator] )<br />;( ----- ----------     ------------     ---------- )<br />( &quot;LEFDefaultRouteSpec&quot; nil &quot;LEFDefaultRouteSpec&quot;<br />   routingDirections(<br />    ( M1 &quot;horizontal&quot; )<br />    ( M2 &quot;vertical&quot; )<br />...<br />   ) ;routingDirections<br />routingGrids(<br />  ( horizontalPitch &quot;M1&quot; 0.2 )<br />  ( verticalPitch &quot;M1&quot; 0.19 )<br />  ( horizontalOffset &quot;M1&quot; 0.1 )<br />  ( verticalOffset &quot;M1&quot; 0.095 )<br /> ) ;routingGrids<br />spacings(<br />  ( minWidth &quot;M1&quot; 0.06 )<br /> ) ;spacings<br />...<br />...<br />interconnect(<br />( validLayers ( M1 M2 M3 M4 M5 M6 ) )<br />( validVias ( M2_M1 M3_M2 M4_M3 M5_M4 M6_M5 ))<br />) ; interconnect<br />) ;LEFDefaultRouteSpec</pre>
<p>You can have multiple&#160;<code>LEFDefaultRouteSpec</code>&#160;constraint groups in the tech graph and specify the one from which rules are to be read. Use the following variable to control the name of the&#160;<code>LEFDefaultRouteSpec</code>&#160;to be read:</p>

<p><code>set init_oa_default_rule &lt;<em>LDRS_CG_name</em>&gt;</code></p>
</li><li>
<p>The&#160;<code>foundry_innovus</code>&#160;constraint group in the&#160;<code>constraintGroups</code>&#160;section: The&#160;<code>foundry_innovus</code>&#160;constraint group captures all the technology rules for all the layers defined in the LEF file apart from the rules that are defined in the&#160;<code>LEFDefaultRouteSpec</code>. This section basically recreates all the LEF technology rules in the ITDB for use of Innovus without any dependency on the foundry section of the base PDK. All the LEF58 layer and library properties from the LEF file are also stored within this section.&#160;<br />Innovus reads this section to populate the technology rules in its database. The&#160;<code>lef2oa</code>&#160;process might create several other constraint groups, such as&#160;<code>minSpacing</code>,&#160;<code>minDualExtension</code>, and so on&#160;and add them as member constraint groups within the&#160;<code>foundry_innovus</code>&#160;group.<br />On the other hand, Virtuoso, by default, reads the technology rules from the&#160;<code>foundry</code>&#160;constraint group&#160;of the tech graph for all its applications.<br />You can have multiple&#160;<code>foundry_innovus</code>&#160;constraint groups in the tech graph and specify the one from which rules are to be read. Use the following variable to control the name of the&#160;<code>foundry_innovus</code>&#160;constraint group&#160;to be read:</p>
<pre><code>set init_oa_foundry_rule &lt;<em>foundry_CG_name</em>&gt;</code></pre><pre>Here&#39;s an example of the&#160;<code>foundry_innovus</code>&#160;constraint group in the&#160;<code>constraintGroups</code>&#160;section:</pre><pre>;( group [override]     [definition]     [operator] )</pre><pre>;( ----- ----------     ------------     ---------- )</pre><pre> ( &quot;foundry_innovus&quot; nil &quot;foundry_innovus&quot;<br />...<br />spacings(<br />...<br />   ( layerProp    &quot;M1&quot; &#39;propName &quot;LEF58_ANTENNAGATEPLUSDIFF&quot; &quot;ANTENNAGATEPLUSDIFF OXIDE1 0.350 ; ANTENNAGATEPLUSDIFF OXIDE2 0.350 ;&quot; )<br />   ( layerProp    &quot;M1&quot; &#39;propName &quot;LEF58_MINSTEP&quot; &quot;MINSTEP 0.10 MAXEDGES 1 MINADJACENTLENGTH 0.10 ;&quot; )<br />   ( layerProp    &quot;M1&quot; &#39;propName &quot;LEF58_RECTONLY&quot; &quot;RECTONLY ;&quot; )<br />   ( layerProp    &quot;M1&quot; &#39;propName &quot;LEF58_RIGHTWAYONGRIDONLY&quot; &quot;RIGHTWAYONGRIDONLY ;&quot; )<br />   ( minWidth     &quot;M1&quot;    0.024 )<br />   ( maxWidth     &quot;M1&quot;    0.25 )<br />   ( minArea      &quot;M2&quot;    0.00288 )<br />   ( minEndOfLineSpacing    &quot;M2&quot;   (0.0405 0.0135 0.06) )<br />  ) ;spacings</pre><pre>memberConstraintGroups(<br />...<br />   &quot;minSpacing&quot;<br />...<br />   ); memberConstraintGroups<br /><br />spacingTables(<br />  ;( constraint           layer1               [layer2]<br />  ; (( index1Definitions  [index2Defintions])  [defaultValue] )<br />  ; ( table) )<br />  ;( --------------------------------------------)<br />  ( minDensity          &quot;M1&quot;<br />...<br />  ( maxDensity          &quot;M1&quot;<br />  )<br /> ) ;spacingTables</pre></li><li>
<p>The&#160;<code>LEFSpecialRouteSpec</code>&#160;constraint group in the&#160;<code>constraintGroups</code>&#160;section: The&#160;<code>LEFSpecialRouteSpec</code>&#160;(LSRS) is used primarily for power routing. It is used to list the viaDefs that should be used at a particular width intersection. It is equivalent to the list of LEF VIARULE statements in LEF.&#160;<br />However, Innovus can use any standardViaDef, even the ones not listed in the LSRS for routing.&#160;<br />Earlier, the via generator used to determine the viaDef to be used on the basis of the order in the LSRS but now priority is given to the cut area and the viaDef that creates the largest cutArea is used.<br />To restrict the via choice,&#160;<code>setViaGenMode -viarule_preference &lt;<em>list of valid vias</em>&gt;</code>&#160;should be used.<br />Here&#39;s an example of the&#160;<code>LEFDefaultRouteSpec</code>&#160;constraint group in the&#160;<code>constraintGroups</code>&#160;section:</p>
<pre>;( group [override]     [definition]     [operator] )<br />;( ----- ----------     ------------     ---------- )<br />( &quot;LEFSpecialRouteSpec&quot; nil &quot;LEFSpecialRouteSpec&quot;</pre><pre>  interconnect(<br />  ( validVias (<br />         (( &quot;layer1Width&quot; nil nil &quot;layer2Width&quot; nil nil )<br />         &#39;viaLayerDirection<br />         (<br />...<br />...<br />) ;LEFSpecialRouteSpec</pre>
<p>You can have multiple&#160;<code>LEFSpecialRouteSpec</code>&#160;constraint groups in the tech graph and specify the one from which rules are to be read. Use the following variable to control the name of the&#160;<code>LEFSpecialRouteSpec</code>&#160;to be read:</p>

<p><code>set init_oa_special_rule &lt;<em>LSRS_CG_name</em>&gt;</code></p>
</li><li>The non-default rules (NDRs)&#160;in the&#160;<code>constraintGroups</code>&#160;section: Separate constraint groups are created for all the NDRs defined in the LEF files and these NDRs are available for use in Innovus. Example:<pre>;( group  [override] )<br /> ;( -----  ---------- )<br /> ( &quot;CTS_Rule&quot; nil<br />   spacings(<br />...<br />  ( minSpacing &quot;M2&quot; 0.13 &#39;soft )<br />  ( minSpacing &quot;M1&quot; 0.13 &#39;soft )<br />  ( minWidth &quot;M1&quot; 0.13 )<br />  ( minWidth &quot;M2&quot; 0.14 )<br />...<br /> ) ;spacings<br /><br />interconnect(<br /> ( validLayers (M1 M2 M3 M4 M5 ) )<br /> ( validVias (VIA12_HV VIA23_VH VIA34_VH VIA45_VH ) )<br />) ;interconnect<br />spacingTables(<br />;( constraint          layer1        [layer2]<br />; (( index1Definitions [index2Defintions]) [defaultValue] )<br />; ( table) )<br />;( --------------------------------------------)<br /> ( minNumCut &quot;V1&quot;<br />   (( &quot;minNumCut&quot; nil nil ) 1)<br />...<br />  )<br />...<br />  ) ;spacingTables<br />) ;CTS_Rule</pre></li><li>
<p>The cutClass definitions in the&#160;<code>layerRules</code>&#160;section:&#160;All the cutClasses defined in the LEF file are added to the ITDB structure. The difference in name with the cutClasses in the base PDK does not matter as long as the width, length and numCuts parameters are in sync with the base PDK. Example:</p>
<pre>cutClasses(<br /> ;( layerName )<br /> ;( (cutClassName                    (width length)) )<br /> ;( ------------------------------------------------ )<br />(V1<br />   (VSQ       &#39;numCuts    1        (0.016 0.016))<br />   (VREC      &#39;numCuts    2        (0.016 0.03))<br />)<br />(V2<br />   (VSQ       &#39;numCuts    1        (0.016 0.016))<br />   (VREC      &#39;numCuts    2        (0.016 0.03))<br />)<br />...<br />...<br />) ;cutClasses</pre><strong>Note</strong>: Even if the name or number of the cutClasses is different in the base PDK and the Rapid PDK, Innovus would always be reading the cutClasses defined in the Rapid PDK. Therefore, a LEF dump from Innovus with the Rapid PDK would show up the same cutClasses as in the technology lef file. However, to avoid any complications, it is recommended that you should keep the names and definitions of the cutClasses in the technology LEF file the same as those in the base PDK while creating the Rapid PDK.</li><li>
<p>The via definitions in the&#160;<code>viaDefs</code>&#160;section: The via definitions from the LEF file, both custom and standard, are also created in the ITDB structure. However, the standard vias from both the base PDK and the Rapid PDK are available to be used in Innovus. Example:</p>
<pre>viaDefs(</pre><pre>standardViaDefs(</pre><pre>;( viaDefName layer1 layer2 (cutLayer cutWidth cutHeight [resistancePerCut])</pre><pre>; (cutRows cutCol (cutSpace) [(l_cutPattern)])</pre><pre>; (layer1Enc) (layer2Enc) (layer1Offset) (layer2Offset) (origOffset)</pre><pre>; [implant1 (implant1Enc) [implant2 (implant2Enc) [well/substrate]]])</pre><pre>;( ----------------------------------------------------------- )</pre><pre>( M2_M1           M1       M2          (&quot;V1&quot; 0.07 0.07 5.0)</pre><pre> (1 1 (0.07 0.07))</pre><pre> (0.005 0.03) (0.005 0.03) (0.0 0.0) (0.0 0.0) (0.0 0.0)</pre><pre>)</pre><pre>( M3_M2           M2       M3          (&quot;V2&quot; 0.07 0.07 5.0)</pre><pre>(1 1 (0.07 0.07))</pre><pre>(0.005 0.03) (0.005 0.03) (0.0 0.0) (0.0 0.0) (0.0 0.0)</pre><pre>)</pre><pre>...</pre><pre>) ;standardViaDefs<br /><br /></pre><pre>customViaDefs(<br />;( viaDefName libName  cellName viewName layer1 layer2 resistancePerCut)<br />;( ---------- -------  -------- -------- ------ ------ ----------------)<br /> ( M2_M1     RapidPDK  M2_M1      via      M1     M2    0.0)<br /> ( M3_M2     RapidPDK  M3_M2      via      M1     M2    0.0)<br />...<br />...<br />) ;customViaDefs</pre></li><li>The site definitions in the&#160;<code>siteDefs</code>&#160;section: The site definitions for the standard cells are also saved in the&#160;<code>siteDefs</code>&#160;section of the ITDB techfile. Example:<br /><pre>siteDefs(<br /> scalarSiteDefs(<br /> ;( siteDefName type width height symInX symInY symInR90)<br /> ;( ----------- ---- ----- ------ ------ ------ -------)<br /> ( CoreSite core 0.2 1.71 nil t nil)<br /> ( PadSite pad 240.0 240.0 nil nil nil)<br /> ) ;scalarSiteDefs<br />) ;siteDefs</pre><strong>Note</strong>: The site definitions are read in from all the libraries specified in the reference library list during the&#160;<code>init_design</code>&#160;step in Innovus. So, if some of the sites are not defined in the technology graph (ITDB structure) but are read from any reference library, they would be saved in the design library. However, during&#160;<code>restoreDesign</code>,&#160;it is expected that the site definitions are part of the technology graph and are not read from the reference libraries.</li><li>The&#160;<code>FIXEDMASK</code>&#160;statement in the&#160;<code>foundry_innovus</code>&#160;constraint group in the&#160;<code>constraintGroups</code>&#160;section: The&#160;<code>FIXEDMASK</code>&#160;statement from the LEF file is mapped to the&#160;<code>colorControl</code>&#160;section of the ASCII tech file in the foundry group. It is set in the&#160;<code>foundry_innovus</code>&#160;constraint group in case the base PDK foundry constraint group does not have this set.&#160;<pre>( &quot;foundry_innovus&quot; nil<br />  ...<br />   colorControl(<br />    ( integrationColorModel &quot;locked&quot; )<br />   ) ;colorControl<br />   ...<br />) ;foundry_innovus</pre></li></ul><h4 id="TechnologyDataPreparation-MappingforOtherKeyRapidPDKConstructs"><span class="cad-head-number">3.2.7.2 </span>Mapping for Other Key Rapid PDK Constructs</h4>
<h5 id="TechnologyDataPreparation-MappingfortheLEFLibraryProperties">Mapping for the LEF Library Properties</h5>
<p>The LIBRARY PROPERTYDEFINITIONS from the LEF file are mapped to&#160;<code>libProp</code>&#160;in the&#160;<code>foundry_innouvs</code>&#160;subsection of the ASCII techfile. They are also set as properties on the Rapid PDK library.&#160;</p>

<p><strong>Note</strong>: If any&#160;<code>libProp</code>&#160;definitions are found in the Rapid PDK while reading the OpenAccess data to Innovus,&#160;the properties set on the library are ignored.</p>

<p>Here&#39;s a sample mapping of the LIBRARY PROPERTYDEFINITIONS in the LEF file to&#160;the ASCII techfile:</p>
<div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col /><col /></colgroup><tbody><tr><th class="confluenceTh">LEF File Section</th><th class="confluenceTh">ASCII Techfile Syntax</th></tr>
<tr><td class="confluenceTd"><pre>PROPERTYDEFINITIONS</pre><pre>  LIBRARY LEF58_FINFET STRING &quot;</pre><pre>  FINFET PITCH 0.056 OFFSET 0.0 HORIZONTAL NOCORECELL ; &quot; ;</pre><pre>END PROPERTYDEFINITIONS</pre></td>
<td class="confluenceTd"><pre>( &quot;foundry_innovus&quot; nil &quot;foundry_innovus&quot;</pre><pre>...</pre><pre>   ( libProp &#39;propName &quot;LEF58_FINFET&quot; &quot;</pre><pre>     FINFET PITCH 0.056 OFFSET 0.0 HORIZONTAL NOCORECELL ; &quot; )</pre><pre>...</pre><pre>) ;foundry_innovus</pre></td>
</tr>
</tbody></table></div>

<p>You can check the LIBRARY PROPERTYDEFINITIONS from the Library Manager in Virtuoso. To do so:</p>
<ol><li>Choose&#160;<em>CIW</em>&#160;-&gt;&#160;<em>Library Manager</em>.</li><li>In the listing of the libraries, right-click the name of the Rapid PDK tech library and select&#160;<em>Properties</em>&#160;from the context menu.<br /><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" data-base-url="https://rdwiki.cadence.com" data-image-src="attachments/425955847/425955848.png" data-linked-resource-container-id="425955847" data-linked-resource-container-version="15" data-linked-resource-content-type="image/png" data-linked-resource-default-alias="LEFtoASCII.png" data-linked-resource-id="425955848" data-linked-resource-type="attachment" data-linked-resource-version="1" data-unresolved-comment-count="0" src="attachments/425955847/425955848.png" width="640" /></span></li></ol>
<p><strong>Note</strong>:&#160;All the properties in the base and Rapid PDKs are read into Innovus. However, if a property with the same name exists in both the base and Rapid PDKs, only the version from the Rapid PDK is read into Innovus.</p>
<h5 id="TechnologyDataPreparation-CheckingforLayerNames,Definitions,andNumberofMasks">Checking for Layer Names, Definitions, and Number of Masks</h5><ul><li>The layer names between the base PDK and the technology LEF file must match. In case of any mismatches, fix the technology LEF using a sed script or the vi editor to match the names with the base PDK before creating the Rapid PDK structure.</li><li>This layer name change would also be needed for the standard cell and NDR LEF files.</li><li>All the layer definitions must exist in the base PDK; any new layers defined in the LEF file will be dropped during the&#160;<code>lef2oa</code>&#160;process.</li><li>If a layer has multiple masks, ensure that the mask number has the same value defined in both the base PDK and the technology LEF file. In case of a mismatch, the number of masks defined in the base PDK will be kept and the LEF mask number will be ignored.</li></ul>
<p>Here is a sample section from the base PDK with the layer definitions and number of masks per layer values:</p>
<pre>layerDefinitions(<br /><br />techLayers(<br />;( techLayer number abbreviation [#Masks] )<br />;( --------- ------ ------------ -------- )<br />...<br /> (  M1        31      M1          2 )<br /> (  M2        32      M2          2 )<br />...<br />) ;techLayers<br />...<br />) ;layerDefinitions</pre>
<p><strong>Note</strong>: Pseudo-material layers, such as routing, cut, and trimmetal, for the region-based rules (Example:&#160;<code>M1_FB1</code>) do not&#160;need to be defined in the base PDK; these are created in the&#160;<em><code>rapidPDK_techLibName</code></em>.</p>
<h5 id="TechnologyDataPreparation-CheckingforRoutingLayerUsageandRoutingDirection">Checking for Routing Layer Usage and Routing Direction</h5><ul><li>Ensure that there is no mismatch&#160;between the LEF file and the base PDK in the layer type definition or usage (for example, whether a layer is used as metal, cut, masterslice and so on).&#160;<code>lef2oa</code>&#160;will give an error if the type in the LEF file does not match the type specified in the base PDK.<br /><strong>Note</strong>: However, if the base PDK has a particular type set, the LEF can be used to update the subclasses of the same type. For example, if the base PDK has a layer with type CUT, the LEF can have the TYPE as IMPLANT and that will be updated. Similarly, for a type routing in the base PDK, the type can be overridden in the tech LEF file.</li><li>Ensure that the routing direction for the metal layers is also the same between the LEF file and the base PDK.</li></ul>
<p>Here is a sample section from the&#160;base PDK with the layer functions:</p>
<pre>layerRules(<br />  functions(<br />;( layer  function  [maskNumber] )<br />;( -----  --------  ------------ )<br />...<br /> ( M1    &quot;metal&quot;    104 )<br /> ( VIA1  &quot;cut&quot;      107 )<br /> ( M2    &quot;metal&quot;    108 )<br />...<br />  ) ;functions<br /><br />  routingDirections(<br />  ;( layer    direction )<br />  ;( -----    --------- )<br />...<br />   ( M1       &quot;vertical&quot; )<br />   ( M2       &quot;horizontal&quot; )<br />...<br />  ) ;routingDirections<br />...<br />) ;layerRules</pre><h5 id="TechnologyDataPreparation-CheckingfortheOALAYERMAPDefinitionforLayerswithMultipleMasks">Checking for the OALAYERMAP Definition for Layers with Multiple Masks</h5>
<p>The&#160;<code>LEF58_OALAYERMAP</code>&#160;construct defined in the techfile can be used to map a layer with multiple masks to different layer names. This is supported only for trim metal layers. You need to make sure that the layermap definition is not repeated in the technology LEF file in case it is already defined in the base PDK.</p>

<p>Consider an example in which the&#160;<code>MASK 1</code>&#160;shapes on LEF layer&#160;<code>CL1</code>&#160;would go to the OpenAccess layer&#160;<code>CL1A</code>&#160;while the&#160;<code>MASK 2</code>&#160;shapes on&#160;<code>CL1</code>&#160;would go to the OpenAccess layer&#160;<code>CL1B</code>. In this case:</p>
<ul><li>Ensure that the layer&#160;<code>CL1</code>&#160;is not defined in the base PDK as that can cause issues with the tool since the shapes will be created on different layers based on the mask number.&#160;</li><li>The layer&#160;<code>CL1</code>&#160;needs to be defined in the technology LEF file, whereas the layers&#160;<code>CL1A</code>&#160;and&#160;<code>CL1B</code>&#160;need to be defined in the base PDK, as shown below.</li></ul><div class="table-wrap"><table class="relative-table wrapped confluenceTable" style="width: 70.3172%;"><colgroup><col style="width: 11.6414%;" /><col style="width: 88.4264%;" /></colgroup><tbody><tr><th class="confluenceTh" colspan="1">LayerMap in the <br />Base Virtuoso techfile</th><td class="confluenceTd"><pre>controls(<br />...<br /> techParams(<br /> ;( parameter   value )<br /> ;( ----------  ----- )<br />  ( LEF58_OALAYERMAP_RapidPDK &quot;OALAYERMAP CL1A LAYER CL1 MASK 1 ; OALAYERMAP CL1B LAYER CL1 MASK 2 ; &quot; )<br />... <br />) ;controls</pre></td>
</tr>
<tr><th class="confluenceTh" colspan="1">LEF File Definition</th><td class="confluenceTd" colspan="1"><pre>LAYER CL1<br />  TYPE MASTERSLICE ; <br />  MASK 2 ; <br />...<br />END CL1</pre></td>
</tr>
</tbody></table></div>

<p><br /></p>

<p><span class="confluence-anchor-link" id="TechnologyDataPreparation-Tskeleton"></span></p>
<h4 id="TechnologyDataPreparation-ASCIITechfileSkeleton"><span class="cad-head-number">3.2.7.3 </span>ASCII Techfile Skeleton</h4>
<pre>; Technology File myTechLib<br />; Generated on MM DD HR:MIN:SEC YYYY<br />; with @(#)$CDS: techLoadDump version BUILDVERSION MM/DD/YYYY HH:MM (machineName) $<br />controls(<br />         ...</pre><pre>         techParams(</pre><pre>         ...</pre><pre>         ) ; techParams<br />         ...<br />) ; controls</pre>
<p><br /></p>
<pre>layerDefinitions(</pre><pre>                 ...</pre><pre>                 techLayers(<br />                 ...</pre><pre>                 ) ;techLayers</pre><pre>                 ...</pre><pre>) ;layerDefinitions</pre><pre><br /></pre><pre>layerRules(</pre><pre>           ...</pre><pre>           functions(</pre><pre>           ...</pre><pre>           ) ;functions</pre><pre>           ...</pre><pre>           cutClasses(</pre><pre>           ...</pre><pre>           ) ; cutClasses</pre><pre>           ...</pre><pre>) ; layerRules</pre>
<p><br /></p>
<pre>viaDefs(</pre><pre>        ...</pre><pre>        standardViaDefs(</pre><pre>        ...</pre><pre>        ) ; standardViaDefs</pre><pre>        ...</pre><pre>        customViaDefs(</pre><pre>        ...</pre><pre>        ) ; customViaDefs</pre><pre>) ;viaDefs</pre>
<p><br /></p>
<pre>constraintGroups(</pre><pre>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ...</pre><pre>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ( &quot;foundry&quot;</pre><pre>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;...</pre><pre>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ) ;foundry</pre><pre>...</pre><pre>) ; constraintGroups</pre>
<p><br /></p>
<pre>siteDefs(</pre><pre>        ...</pre><pre>        scalarSiteDefs(</pre><pre>        ...</pre><pre>        ) ; scalarSiteDefs</pre><pre>) ;siteDefs</pre>
<p><strong><br /></strong></p>

                    </div>
<br /><br /></div>
<footer xmlns:html="http://www.w3.org/1999/xhtml"><nav class="navigation"><b><em><a href="Overview_of_Mixed_Signal_Interoperability.html" id="prev" title="Overview_of_Mixed_Signal_Interoperability">Overview_of_Mixed_Signal_Inter ...</a></em></b><b><em><a href="Design_Data_Preparation.html" id="nex" title="Design_Data_Preparation">Design_Data_Preparation</a></em></b></nav><div>
          For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2023, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved.
        </div>
</footer><br xmlns:html="http://www.w3.org/1999/xhtml" />
<div id="cad_image_modal" style="background-color: rgba(0, 0, 0, 0.6);"><center id="cad_image_modal_center">&#160;&#10240;</center><span style="margin-right:50px;margin-top:100px;font-weight:bold;font-size:20px;background:#e5e5e5;border:1px solid #e5e5e5;border-radius:25px;height:30px;width:20px;padding-left:6px;padding-top:2px;color: black;" onclick="document.querySelector('#cad_image_modal').classList.remove('opac');">X</span></div>

</body></html>