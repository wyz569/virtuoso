
<html><head><title>Translating Dracula Files</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="Approver" content="Technical Publications" />
<meta name="Author" content="sarita" />
<meta name="CreateDate" content="2023-05-02" />
<meta name="CreateTime" content="1683027645" />
<meta name="DataType" content="Manuals" />
<meta name="Description" content="The Diva verification tool lets you check physical design and electrical functionality, perform layout versus schematic comparisons, and view errors interactively to speed diagnosis and correction." />
<meta name="DocTitle" content="Diva Reference" />
<meta name="DocType" content="Reference" />
<meta name="FileTitle" content="Translating Dracula Files" />
<meta name="FileType" content="Chapter" />
<meta name="FMWikiRelease" content="FM-Wiki-4.0.0" />
<meta name="Keyword" content="divaref" />
<meta name="Language" content="English" />
<meta name="ModifiedDate" content="2023-05-02" />
<meta name="ModifiedTime" content="1683027645" />
<meta name="NextFile" content="appC.html" />
<meta name="Group" content="" />
<meta name="Platform" content="Physical Verification  Analysis" />
<meta name="PrevFile" content="appA.html" />
<meta name="c_product" content="Diva" />
<meta name="Product" content="Diva" />
<meta name="ProductFamily" content="Diva" />
<meta name="ProductVersion" content="IC23.1" />
<meta name="RightsManagement" content="Copyright 2023 Cadence Design Systems Inc." />
<meta name="Title" content="Diva Reference -- Translating Dracula Files" />
<meta name="Keywords" content="" />
<meta name="topic_type" content="" />
<meta name="reference_type" content="" />
<meta name="prod_feature" content="" />
<meta name="prod_subfeature" content="" />
<meta name="new_topic" content="No" />
<meta name="spotlight_topic" content="0" />
<meta name="Version" content="IC23.1" />
<meta name="SpaceKey" content="divarefIC231" />
<meta name="webflare-version" content="2.5" />
<link rel="stylesheet" href="styles/webflare.css" type="text/css" />


  <script>/*<![CDATA[*/
 document.addEventListener("DOMContentLoaded", function(event) {  document.querySelectorAll("img").forEach((img, index) => {
if (img.hasAttribute("usemap")){return;}else{img.classList.add("cursorclass");} img.addEventListener("click", (e) => {if(img.hasAttribute("usemap")){            img.setAttribute("style","cursor:none;");return;};document.querySelector("#cad_image_modal").classList.add("opac");document.querySelector("#cad_image_modal_center").innerHTML = `<img style="position:absolute;top:0;bottom:0;left:0;right:0;margin: auto;max-height:95%;"  src="${e.target.src}">`;});});});
/*]]>*/</script> 




 <style>/*<![CDATA[*/
.cursorclass{cursor:pointer;}#cad_image_modal{position:fixed;left:0;top:0;width:100%;background:#00000099;overflow:hidden;height:0;opacity:0;transition: height 0ms 1s, opacity 1s 0ms;}#cad_image_modal.opac{height: 100%;opacity: 1;transition: height 0ms 0ms, opacity 1s 0ms;}#cad_image_modal span{position:fixed;right:10px;top:10px;cursor:pointer;color:#fff;}
/*]]>*/</style> 
</head><body style="background-color: #FFFFFF;"><a name="pagetop"></a>
<!-- Begin Buttons -->
<header><div class="docHeadr">Product Documentation<img src="icons/Cadence-Logo.jpg" /></div><nav class="blueHead"><ul><li><a class="content" href="divarefTOC.html">Contents</a></li><li><a class="prev" href="appA.html" title="What&#8217;s New In Diva">What&#8217;s New In  ...</a></li><li style="float: right;"><a class="viewPrint" href="divaref.pdf">View/Print PDF</a></li><li style="float: right;margin-right: 25px;"><a class="nextd" href="appC.html" title="Improving Hierarchical DRC Performance">Improving Hierarchical DRC Per ...</a></li></ul></nav></header>
<!-- End Buttons -->
<h5><center>Diva Reference<br />Product Version IC23.1, June 2023</center></h5><div id="main-content" style="min-height: 50vh; margin-left: 5%; margin-right: 2%;"><a name="#firstpage"></a>

<h1>B
<a id="pgfId-1008781"></a></h1>
<h1>
<a id="pgfId-1011663"></a><hr />
Translating Dracula Files<hr />
</h1>
<h2>
<a id="pgfId-1014198"></a><a id="marker-1014197"></a>Dracula To Diva Verification Translator: DraculaToDiva</h2>

<p>
<a id="pgfId-1014200"></a><a id="marker-1014199"></a>The <em>DraculaToDiva </em>program translates a Dracula rules file into an Diva verification rules file.</p>
<p>
<a id="pgfId-1014201"></a>Before you translate your files</p>
<ul><li>
<a id="pgfId-1014202"></a>Make sure that the directory containing <em>DraculaToDiva </em>is in your search path. </li><li>
<a id="pgfId-1014203"></a>Make sure that you have a Dracula rules file.</li></ul>


<h3>
<a id="pgfId-1014204"></a>Running DraculaToDiva</h3>

<p>
<a id="pgfId-1014205"></a>You can execute <em>DraculaToDiva </em>from any UNIX prompt.</p>
<p>
<a id="pgfId-1014206"></a>When you invoke <em>DraculaToDiva</em>, the Dracula program heading appears, along with a colon (:) prompt. </p>

<div class="webflare-div-image">
<img width="676" height="116" src="images/appB-2.gif" /></div>

<p>
<a id="pgfId-1014218"></a>You can use these PDRACULA commands with <em>DraculaToDiva</em>.</p>

<p><strong>
<a id="pgfId-1014219"></a><code>/get</code></strong></p>

<p class="webflare-indent1">
<a id="pgfId-1016400"></a> Specifies the rules file to be translated.
syntax: <code>get [filename][nolist]
</code>or
<code>/get</code></p>
<p class="webflare-indent1">
<a id="pgfId-1014220"></a> The <em>nolist</em> option causes the rules file not to be displayed on the screen. </p>
<p class="webflare-indent1">
<a id="pgfId-1014221"></a> Use the <em>nolist</em> option to display all Dracula errors in a group, rather than interspersed between the scrolling rules-file text.</p>

<p><strong>
<a id="pgfId-1014222"></a><code>/finish</code></strong></p>
<p class="webflare-indent1">
<a id="pgfId-1016409"></a> Tells the translator that input is complete and generates the new Diva verification rules file.</p>
<p><strong>
<a id="pgfId-1016414"></a><code>/abort</code></strong></p>
<p class="webflare-indent1">
<a id="pgfId-1016417"></a> Terminates translator operation.</p>

<p>
<a id="pgfId-1014224"></a>Other PDRACULA commands can be used with <em>DraculaToDiva</em>. Refer to the <h-hot><a actuate="user" class="URL" href="../dracularef/dracularefTOC.html#firstpage" show="replace" xml:link="simple">Dracula Reference Manual</a></h-hot> for more information.</p>

<h3>
<a id="pgfId-1014227"></a>What Happens During Translation?<a id="What Happens During Translation?"></a></h3>

<p>
<a id="pgfId-1014228"></a>When you type <em>/get</em> and specify the rules file, <em>DraculaToDiva </em>scans the file and displays errors on the screen. </p>
<p>
<a id="pgfId-1014229"></a>When you type <em>/finish</em>, <em>DraculaToDiva </em>generates an Diva verification&#160;&#160;rules file. </p>

<h3>
<a id="pgfId-1014231"></a>Dracula To Diva Verification  Command Correspondence<a id="Dracula to Diva Command Correspondence"></a></h3>

<p>
<a id="pgfId-1014232"></a>These figures list Dracula commands and their corresponding Diva verification commands. For more information about Dracula or Diva verification commands, see the <h-hot><a actuate="user" class="URL" href="../dracularef/dracularefTOC.html#firstpage" show="replace" xml:link="simple">Dracula Reference Manual</a></h-hot>.</p>

<p>
<a id="pgfId-1015204"></a></p>
<table class="webflareTable" id="#id1014234">
<caption style="text-align:left;"><p>
</p><div class="ft-figtabl-title">
<a id="pgfId-1015208"></a>Dracula To Diva Command Correspondence</div></caption>
<tbody><tr>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1014236">
<a id="pgfId-1014236"></a>Dracula command</span>
</th>
<th class="webflareTh" colspan="1" rowspan="1">
<span class="tbl-head" id="#id1014238">
<a id="pgfId-1014238"></a>Diva Verification command </span>
</th>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<span class="tbl-head" id="#id1014240">
<a id="pgfId-1014240"></a>LAYER Processing &#8211; Logical</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014244"></a>OR layerA layerB layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014246"></a>layerC = geomOr( layerA layerB )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014248"></a>AND layerA layerB layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014250"></a>layerC = geomAnd( layerA layerB )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014252"></a>NOT layerA layerB layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014254"></a>layerC = geomAndNot( layerA layerB )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014256"></a>XOR layerA layerB layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014258"></a>layerC = geomXor( layerA layerB )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014260"></a>FLATTEN layerA layerB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014262"></a>layerB = geomCat( layerA )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014264"></a>HIERARCHEN layerA layerB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014266"></a>No corresponding Diva verification command.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014268"></a>SELECT layerA INSIDE layerB layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014270"></a>layerC = geomInside( layerA layerB )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014272"></a>SELECT layerA OUTSIDE layerB layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014274"></a>layerC = geomOutside( layerA layerB )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014276"></a>SELECT layerA CUT layerB layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014278"></a>layerC = geomStraddle( layerA layerB )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014280"></a>SELECT layerA ENCLOSE layerB layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014282"></a>layerC = geomEnclose( layerA layerB )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014284"></a>SELECT layerA VERTEX[n1:n2] layerB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014286"></a>layerB = geomGetVertex( layerA n1&lt;= keep
&#160;&#160;&#160;&#160;&lt;=n2 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014288"></a>SELECT layerA LABEL labelname layerB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014290"></a>layerB = geomGetNet( layerA &quot;labelname&quot; )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014292"></a>SELECT layerA HOLE layerB layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014294"></a>layerC = geomEnclose( geomInside<br />( geomHoles (layerA) layerB ) layerB )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014296"></a>SELECT layerA TOUCH[n1:n2]layerB layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014298"></a>layerC = geomButting( layerA layerB n1
&#160;&#160;&#160;&#160;&lt;= keep &lt;= n2 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014300"></a>SIZE layerA by n layerB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014302"></a>layerB = geomSize( layerA n )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014304"></a>OUTPUT ERR 10</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014306"></a>saveDerived( ERR10 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014312"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014314"></a><strong>Note:</strong> The Diva verification drc command automatically stores the result in the database, so it is not necessary to use the Diva verification saveDerived command.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014316"></a>RELOCATE</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014318"></a>No corresponding Diva verification command.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014320"></a>CUT</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014322"></a>No corresponding Diva verification command.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<span class="tbl-head" id="#id1014324">
<a id="pgfId-1014324"></a>Layer Connectivity</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1014328"></a><code>CONNECT <br />*input-layer<br />L1 = 1<br />L2 = 2 text = 20 attach L4 <br />L3 = 3 ctext = 21 <br />connect-layer = L1 L2 L3<br />*end<br />*operation<br />connect L2 L1 by via<br />connect L3 L2 by contact<br />connect L3 L1 by contact<br />*end </code></pre>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014330"></a>geomConnect(<br />via( via L2 L1 )<br />via( contact L3 L2 L1 )<br />label( &#8220;text&#8221; L4 )<br />label( &#8220;ctext&#8221; L1 L2 L3 ) )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<pre class="webflare-courier-new codeContent">
<a id="pgfId-1014332"></a></pre>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014334"></a><strong>Note:</strong> You need to change the label names inside the label clause to the names you use in the Diva verification database.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014336"></a>STAMP layerA by layerB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014338"></a>layerA = geomStamp( layerA layerB )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014340"></a>LINK</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014342"></a>No corresponding Diva verification command.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014344"></a>RCONNECT</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014346"></a>RCONNECT is used to form parasitic resistance.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014348"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">

<div class="webflare-information-macro webflare-macro-note">
<a id="pgfId-1014350"></a>Since there is nostraightforward way to transform Draculaparasitic-resistance checking to Diva verification commands, all RCONNECT statements are commented out. Messages are displayed on the screen or in the file.</div>

</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<span class="tbl-head" id="#id1014352">
<a id="pgfId-1014352"></a>Design Rule Checks</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014356"></a>WIDTH layerA op n1 n2 layerB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014358"></a>layerB = drc( layerA n1 &lt;= width 
&#160;&#160;&#160;&#160;&lt;= n2 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014360"></a>ENC layerA layerB op n1 n2 layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014362"></a>layerC = drc( layerB layerA n1 &lt;= enc
&#160;&#160;&#160;&#160;&lt;= n2 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014364"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014366"></a>The Dracula ENC layerA layerB checks for layerB enclosing layerA. In Diva verification, the order is reversed, and layerB is specified as the first layer.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014372"></a>EXT layerA layerB op n1 n2 layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014374"></a>layerC = drc( layerA layerB n1 &lt;= sep
&#160;&#160;&#160;&#160;&lt;= n2 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014376"></a>INT layerA layerB op layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014378"></a>layerC = drc( layerA layerB n1 &lt;= ovlp
&#160;&#160;&#160;&#160; &lt;= n2 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014380"></a>LENGTH layerA op n1 layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014382"></a>Temp-File1 = geomGetLength( Temp-file2 
&#160;&#160;&#160;&#160;length op n1 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014384"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014386"></a>LENGTH can only be used in a spacing conjunction rule and does not need the edge modifier. See the example. </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014388"></a>enc L3 L1 Lt .001 &amp;<br />length L3 Le .002 &amp;<br />enc L3 L2 Lt .003 out err 11</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014390"></a>TEMP_?1 = drc( L1 L3 enc &lt; .001 edge )
?L3 = geomAnd( TEMP_?1 L3 )
?L1 = geomAnd( TEMP_?1 L1 ) 
TEMP_?1 = geomGetLength(?L3 length
&#160;&#160;&#160;&#160;&lt;=.002)<br />?L3 = geomAnd( TEMP_?1 ?L3 ) <br />drc( L2 ?L3 enc &lt; .003 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014392"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014394"></a>In the previous example, the temporary layer ?L1 is not used later, so the Diva verification compiler optimizes it when you run the job. </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014396"></a>AREA layerA RANGE n1 n2 layerB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014398"></a>layerB = drc( layerA n1 &lt;= area &lt;= n2 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014400"></a>OVERLAP layerA layerB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014402"></a>layerB = geomAnd( layerA )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014404"></a>PLENGTH layerA RANGE n1 n2 layerB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014406"></a>layerB = geomGetLength( layerA n1 &lt;=
&#160;&#160;&#160;&#160; length &lt;= n2 contiguous )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<span class="tbl-head" id="#id1014408">
<a id="pgfId-1014408"></a>Dracula DRC Options</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<p>
<a id="pgfId-1014412"></a>When a Dracula DRC command has one or more options, DraculaToDiva translates the option(s) to an Diva verification <code>drc</code> command with modifiers. Where needed, additional commands are added by DraculaToDiva for specific options.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014416"></a>[C]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014418"></a>Uses Diva verification <em>parallel</em> modifier.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014420"></a>[C&#8217;]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014422"></a>Uses Diva verification&#160;&#160;<em>notParallel</em> modifier.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014424"></a>[E]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014426"></a>Combines the commands.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014428"></a>   ENC[E]layerA layerB op n1 n2 layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014430"></a>layerC=drc( layerB layerA n1 &lt;=op &lt;=n2 )<br />saveDerived( geomOutside(layerA layerB ) )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014432"></a>   EXT[E]layerA layerB op n1 n2 layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014434"></a>layerC=drc( layerA layerB n1 &lt;=sep &lt;=n2 )<br />saveDerived( geomInside(layerA layerB ) )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014436"></a>[EO]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014438"></a>Combines the commands.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014444"></a>   EXT[EO]layerA layerB op n1 n2 layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014446"></a>layerC=drc( layerA layerB n1 &lt;=sep &lt;=n2 )<br />saveDerived( geomOverlap(layerA layerB ) )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014448"></a><code>[G] </code>or <code>[O]</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014450"></a>Combines the commands.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014452"></a>   EXT[G]layerA layerB op n1 n2 layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014454"></a>layerC = drc( layerA layerB n1&lt;=sep &lt;=n2 ) saveDerived( geomStraddle (layerA layerB )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014456"></a>[H]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014458"></a>Combines the commands.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014460"></a>   EXT[H] layerA op n1 n2 layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014462"></a>layerC=drc( layerA n1 &lt;=sep &lt;=n2 )<br />drc( layerA n1 &lt;=notch &lt;=n2 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014464"></a>[N]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014466"></a>Uses Diva verification <em>diffNet</em> modifier.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014468"></a>[N&#8217;]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014470"></a>Uses Diva verification <em>sameNet</em> modifier.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014472"></a>[P]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014474"></a>Uses Diva verification opposite modifier.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014476"></a>[P&#8217;]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014478"></a>Uses Diva verification app&lt;0 modifier.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014480"></a>[R] [R&#8217;]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014482"></a>Default Diva verification operation generates shapes. Default Dracula operation generates edges. When you do not specify the [R] or [R&#8217;] option in a Dracula command file, DraculaToDiva automatically adds an edge modifier. When you specify an [R] modifier in the Dracula command file, also specify the Diva verification opposite modifier.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014484"></a><code>SELLE</code> or<code> SELLT</code></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014486"></a>Uses Diva verification <em>fig</em> modifier.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014488"></a>[T]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014490"></a>Default Diva verification operation has touching on. Whenever there is no [T] specified in the Dracula DRC, and there is no lower bound, <em>DraculaToDiva</em> adds a lower bound of 0 without the equal sign.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014492"></a>EXT layerA layerB LT 0.5 layerC </p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014494"></a>layerC = drc( layerA layerB 0 &lt;sep &lt;0.5 ) </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014496"></a>EXT[T]layerA layerB LT 0.5 layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014498"></a>layerC = drc( layerA layerB sep &lt; 0.5 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014500"></a>[U]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014502"></a>Ignored.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014504"></a>[U&#8217;]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014506"></a>Ignored.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014508"></a>[V]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014510"></a>Ignored.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<span class="tbl-head" id="#id1014512">
<a id="pgfId-1014512"></a>Layout Extraction</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014516"></a>ELEMENT MOS[type] layerA layerB layerC layerD</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014518"></a>extractDevice( layerA layerB(&quot;G&quot;) layerC (&quot;S&quot; &quot;D&quot;) layerD(&quot;B&quot;) model )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014520"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014522"></a>For example, the model can be &#8220;pfet&#8221; or &#8220;nfet,&#8221; depending on whether the MOS is p-type or n-type.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014524"></a>ELEMENT RES[type] layerA layerB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014526"></a>extractDevice( layerA layerB(&quot;PLUS&quot;<br />&quot;MINUS&quot;) &quot;resistor&quot; )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014528"></a>ELEMENT CAP[type] layerA layerB layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014530"></a>extractDevice( layerA layerB(&quot;PLUS&quot;) layerC(&quot;MINUS&quot;) &quot;capacitor&quot; )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014532"></a>ELEMENT DIO[type] layerA layerB layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014534"></a>extractDevice( layerA layerB(&#8220;PLUS&#8221;) layerC(&quot;MINUS&quot;) &quot;diode&quot; )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014536"></a>ELEMENT BJT[type] layerA layerB layerC layerD&#160;&#160;&#160;&#160;</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014538"></a>extractDevice( layerA layerB(&quot;collector&quot;) layerC(&quot;base&quot;) layerD(&quot;emitter&quot;) &quot;bjt&quot; )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014540"></a>ELEMENT PAD layerA layerB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014542"></a>Not implemented.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014544"></a>ELEMENT BOX layerA layerB layerC<br />layerD layerE</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014546"></a>extractDevice( layerA layerB(&quot;pos1&quot;) layerC(&quot;pos2&quot;) layerD(&quot;pos3&quot;) layerE(&quot;pos4&quot;) &quot;BOX&quot; ) </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014548"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014550"></a><em>BOX</em> is the user-defined device name.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<span class="tbl-head" id="#id1014552">
<a id="pgfId-1014552"></a>PARAMETER CAP</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014556"></a>ELEMENT CAP[type] layerA layerB layerC<br />PARAMETER CAP[type] n1 n2</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014558"></a>area = measureParameter( area (layerA) n1 )<br />saveParameter( area &#8220;ca&#8221; ) <br />peri = measureParameter( perimeter saveParameter(peri &#8220;cp&#8221;)(layerA) n2 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<span class="tbl-head" id="#id1014560">
<a id="pgfId-1014560"></a>PARAMETER RES</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014564"></a>ELEMENT RES[type] layerA layerB<br />PARAMETER RES[type] n1</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014566"></a>area = measureParameter( area (layerA) ) width = measureParameter( length 
&#160;&#160;&#160;&#160;( layerA butting layerB) 0.5 ) resist = calculateParameter(area / 
&#160;&#160;&#160;&#160;( width * width)* n1 )
&#160;&#160;&#160;&#160;saveParameter(resist &#8220;r&#8221;)</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014568"></a>PARASITIC CAP</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014570"></a>See ATTRIBUTE CAP.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<span class="tbl-head" id="#id1014572">
<a id="pgfId-1014572"></a>ATTRIBUTE CAP</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014576"></a>PARASITIC CAP[type] layerA layerB<br />layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014578"></a>area = measureParasitic( area 
&#160;&#160;&#160;&#160;( layerA over layerC )two_net ) </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014580"></a>ATTRIBUTE CAP[type] n1 n2</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014582"></a>peri = measureParasitic( perimeter 
&#160;&#160;&#160;&#160;( layerA over layerC ) two_net )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014588"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014590"></a>capacitor = calculateParasitic( (area*n1)+
&#160;&#160;&#160;&#160;(peri*n2) ) 
saveParasitic( capacitor &#8220;PLUS&#8221; &#8220;MINUS&#8221; 
&#160;&#160;&#160;&#160;&#8220;c&#8221; &#8220;capacitor&#8221; ) </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<span class="tbl-head" id="#id1014592">
<a id="pgfId-1014592"></a>fringe-cap example:</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014596"></a>PARASITIC CAP[type] layerA layerA layerA</p>
<p>
<a id="pgfId-1014597"></a>ATTRIBUTE CAP[type] n1 n2</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014599"></a>fringecap = measureFringe( layerA
&#160;&#160;&#160;&#160;calculate((l*n2)/s) <br />sep &lt;= n1 parallel opposite)</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014601"></a>PARASITIC RES</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014603"></a>See ATTRIBUTE RES.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<span class="tbl-head" id="#id1014605">
<a id="pgfId-1014605"></a>ATTRIBUTE RES</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014609"></a>PARASITIC RES[type] layerA layerB</p>
<p>
<a id="pgfId-1014610"></a>ATTRIBUTE RES[type] n1</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014612"></a>area = measureParasitic( area( layerA )
&#160;&#160;&#160;&#160;two_net )
width = measureParasitic( length &#160;&#160;&#160;&#160;( layerA
&#160;&#160;&#160;&#160;butting layerB ) 0.5 two_net )
resist = calculateParasitic( area/(width *
&#160;&#160;&#160;&#160;width ) * n1)
saveParasitic( resist &#8220;PLUS&#8221; &#8220;MINUS&#8221; &#8220;r&#8221;
&#160;&#160;&#160;&#160;&#8220;resist&#8221; )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014614"></a>PARASITIC DIO</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014616"></a>In PARASITIC DIO, <em>layerD</em> and <em>layerE</em> are optional; if they do not appear, you do not need to calculate a2, p2, a3, and p3.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014618"></a>PARASITIC DIO[type] layerA layerB layerC layerD layerE</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014620"></a>a1 = measureParasitic( area (layerA over layerB not_over layerD not_over layerE) two_net )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014622"></a>If P-N diode, then layerA over layerC</p>
<p>
<a id="pgfId-1014623"></a>If N-P diode, then layerA over layerB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014625"></a>p1 = measureParasitic( perimeter (layerA over layerB outside layerD outside <br />layerE) two_net ) <br />a2 = measureParasitic( area (layerA over layerD not_over layerE) two_net )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014627"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014629"></a>p2 = calculateParasitic( measureParasitic ( perimeter (layerA over layerD outside layerE) two_net) + measureParasitic( perimeter (layerA butting layerD <br />outside layerE) two_net) )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014631"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014633"></a>a3 = measureParasitic( area (layerA over layerE) two_net )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014639"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014641"></a>p3 = calculateParasitic( measureParasitic<br />(perimeter (layerA over layerE)<br />two_net) + measureParasitic( length <br />(layerA butting layerE) two_net) )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<p>
<a id="pgfId-1014643"></a> saveParasitic( (a1 p1) &#8220;PLUS&#8221; &#8220;MINUS&#8221; (&#8220;a1&#8221; &#8220;p1&#8221;) &#8220;diode&#8221; )<br /> saveParasitic( (a2 p2) &#8220;PLUS&#8221; &#8220;MINUS&#8221; (&#8220;a2&#8221; &#8220;p2&#8221;) &#8220;diode&#8221; )<br /> saveParasitic( (a3 p3) &#8220;PLUS&#8221; &#8220;MINUS&#8221; (&#8220;a3&#8221; &#8220;p3&#8221;) &#8220;diode&#8221; )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014647"></a>DEVTAG</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014649"></a>DEVTAG is used to attach a device number to a certain layer, enabling you to extract the parameter from that layer via LEXTRACT. In Diva verification, the approach is reversed. You first calculate the parameters of a specific layer, which is not a recognition layer, and then you associate that layer to the recognition layer. See the example under <em>LEXTRACT</em>.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<span class="tbl-head" id="#id1014651">
<a id="pgfId-1014651"></a>LEXTRACT</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014655"></a>ELEMENT BJT[type] layerA layerA<br />layerB layerC<br />DEVTAG BJT[type] layerC layerD<br />DEVTAG[l] layerD layerE layerF<br />.......<br />LEXTRACT parset layerF by BJT[type]<br />outfile &amp;</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014657"></a>extractDevice( layerA layerA(&#8220;collector&#8221; ) layerB(&#8220;base&#8221;) layerC(&#8220;emitter&#8221;) &#8220;bjt&#8221; )<br />
area = measureParasitic( area (layerE over layerC) figure )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014659"></a>LEXTRACT parset layerA by BJT[type]</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014661"></a>attachParasitic( area &#8220;prop_1&#8221; layerA   layerC ) <br />peri = measureParasitic( perimeter(layerE   over layerC) figure ) <br />attachParasitic( peri &#8220;prop_2&#8221; layerA<br />  layerC ) <br />area = measureParameter( area (layerA)) saveParameter(area &#8220;a&#8221;) <br />peri = measureParameter( perimeter <br />  (layerA) ) <br />saveParameter(peri &#8220;l&#8221;)</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014663"></a>EQUATION</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014665"></a>EQUATION is used for flexible parameter extraction with the LEXTRACT command. You calculate the primitive parameters for each different type of device and then use calculateParameter for the EQUATION.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014671"></a>ELEMENT BJT[type] layerC layerA<br />  layerB layerC</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014673"></a>area = measureParameter( area (layerC) ) saveParameter(area &#8220;a&#8221;) <br />peri = measureParameter( perimeter <br />(layerC) )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014675"></a>LEXTRACT parset layerC by BJT[type]<br />outfile &amp;</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014677"></a>saveParameter(peri &#8220;l&#8221;)<br />c1 = calculateParameter(1.2 * area + <br />  1.3 * peri)</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014679"></a>EQUATION c1 = 1.2 * area + 1.3 * peri</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014681"></a>saveParameter(c1 &#8220;c1&#8221;)</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014683"></a>LPESELECT</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014685"></a>Ignored.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014687"></a>LPECHK</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014689"></a>LPECHK compares the layout and schematics and cannot be translated.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014691"></a>NDCOUNT</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014693"></a>If <em>layerC</em> is the source-drain layer, <em>DraculaToDiva</em> assigns &#8220;S&#8221; and &#8220;D&#8221; as the layer&#8217;s terminal types.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014695"></a></p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014697"></a>In this example, an MOS element is defined as</p>
<p>
<a id="pgfId-1014698"></a>ELEMENT MOS[P]layerA layerB layerC</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014700"></a>  NDCOUNT MOS[P] layerC GT 2</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014702"></a>checkDeviceNetCount( &quot;pfet&quot; (&quot;S&quot; &quot;D&quot;) <br />  keep &gt; 2)</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014704"></a>ECONNECT</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014706"></a>If layerA is the source-drain layer, <em>DraculaToDiva</em> assigns &#8220;S&#8221; and &#8220;D&#8221; as its terminal types. The conjunction rule cannot be translated. If using DISC, <em>DraculaToDiva</em> uses checkNotConnected.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014708"></a>  ECONNECT MOS[P] layerA CONN VDD</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014710"></a>checkConnected( &quot;pfet&quot; (&quot;S&quot; &quot;D&quot;) (&quot;VDD&quot;) )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014712"></a>LCONNECT</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014714"></a>The connect-layers in a <em>geomCat</em> are a list of all the connect layers that are defined by the connect-layer command in the input-layer block of a Dracula rules file. The <em>geomGetNet</em> command is placed in the <em>drcExtractRules</em> section of the corresponding Diva verification rules file.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014716"></a>  LCONNECT layerA CONN VDD</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014718"></a>geomGetNet( geomCat( connect-layers)
&#160;&#160;&#160;&#160;   &quot;VDD&quot; )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014720"></a>  LCONNECT layerB DISC VDD</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014722"></a>temp = geomGetNet( geomCat(connect-
&#160;&#160;&#160;&#160;          layers) &#8220;VDD&#8221; ) geomAndNot( layerB temp )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014724"></a>ELCOUNT</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014726"></a>If layerA is the source-drain layer, <em>DraculaToDiva</em> assigns &#8220;S&#8221; and &#8220;D&#8221; as its terminal types. The conjunction rule cannot be translated. </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014732"></a>  ELCOUNT MOS[P] layerA GT 1</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014734"></a>checkFanOut( &quot;pfet&quot; (&quot;S&quot; &quot;D&quot;) keep &gt; 1 )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014736"></a>PATHCHK</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014738"></a>If you use nonstandard labels for power or ground in your Dracula erc rules file, you need to modify the labels in the translated Diva verification file by using <em>setPower</em> or <em>setGround</em>.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014740"></a>  PATHCHK LEVEL 1 OUTPUT ERR 10</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014742"></a>setPower( &#8220;VDD&#8221; &#8220;VCC&#8221; &#8220;PWR&#8221; ) <br />setGround( &#8220;VSS&#8221; &#8220;GND&#8221; ) <br />checkPullUp( ) <br />checkPullDown( ) </p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014744"></a>PROBE</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014746"></a>The translated rule appears in the drcExtractRules part. The conjunction rule cannot be translated.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014748"></a>PROBE VDD OUTPUT VDDNET 10</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014750"></a>tempt = geomGetNet( geomCat(connect-<br />layers) &#8220;VDD&#8221; ) <br />saveDerived( tempt(&#8220;y0&#8221; &#8220;drawing&#8221;)&#160;&#160; ext_view) )</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014752"></a>MULTILAB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014754"></a>Diva verification automatically executes MULTILAB.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014756"></a>SAMELAB</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014758"></a>Diva verification automatically executes SAMELAB.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="2" rowspan="1">
<span class="tbl-head" id="#id1014760">
<a id="pgfId-1014760"></a>Layout Vs. Schematic</span>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014764"></a>LVSCHK</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014766"></a>No corresponding Diva verification command. Whenever LVSCHK or <em>LPECHK</em> appear in the rules file, DraculaToDiva inserts an <em>lvsRules</em> block and a comment asking you to run the LVS interactively, using Diva verification LVS.</p>
</td>
</tr>
<tr>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014768"></a>LVSPLOT</p>
</td>
<td class="webflareTd" colspan="1" rowspan="1">
<p>
<a id="pgfId-1014770"></a>No corresponding Diva verification command.</p>
</td>
</tr>
</tbody></table>
<h3>
<a id="pgfId-1014773"></a><a id="marker-1014772"></a>SQUARE Check</h3>

<p>
<a id="pgfId-1014774"></a>Dracula has a check similar to the Diva verification check for alignment and registration checking, called the SQUARE check. The philosophy of the SQUARE check is different. This section includes a brief description of this check and the methodology for translating rules from DraculaToDiva checking.</p>

<h3>
<a id="pgfId-1014775"></a>Checking Philosophy</h3>

<p>
<a id="pgfId-1014776"></a>The SQUARE check has normal spacing dimensions parallel to edges, but has special checks at 90 degree corners. There are two corner dimensions involved. The first dimension is for the source corner to a destination edge. The second dimension is for the source corner to a destination corner. The way in which these dimensions are applied is illustrated by these examples.</p>

<div class="webflare-div-image">
<img width="674" height="363" src="images/appB-3.gif" /></div>

<p>
<a id="pgfId-1014803"></a>This example shows a corner to edge spacing. The normal side spacing is &#8220;S&#8221; but the spacing at 45 degrees on the corners is X root 2.</p>
<p>
<a id="pgfId-1014804"></a>The basic intent behind this rule is to simulate the case of sizing the original shape by one value and then checking the regular spacing by a second value. The same check with the Diva verification rules is shown.</p>

<div class="webflare-div-image">
<img width="606" height="338" src="images/appB-4.gif" /></div>

<p>
<a id="pgfId-1014848"></a>The original edge face spacing value remains the same. In the Diva verification example, the corner spacing is calculated</p>

<pre class="webflare-courier-new webflare-indent1 codeContent">
<a id="pgfId-1014849"></a>g + g + (S-2g)</pre>

<p>
<a id="pgfId-1014853"></a>This is equivalent to the Dracula corner to edge spacing of</p>

<div class="webflare-div-image">
<img width="660" height="30" src="images/appB-5.gif" /></div>

<p>
<a id="pgfId-1014854"></a>Putting the two together we get the conversion calculation of</p>

<pre class="webflare-courier-new webflare-indent1 codeContent">
<a id="pgfId-1014855"></a>x = ((-1)g+s) /</pre>

<p>
<a id="pgfId-1014907"></a>The same check, except with corner to corner, is shown.</p>

<div class="webflare-div-image">
<img width="606" height="356" src="images/appB-6.gif" /></div>

<p>
<a id="pgfId-1014908"></a>For exactly 45 degree separation, the Diva verification corner spacing is calculated as</p>

<pre class="webflare-courier-new webflare-indent1 codeContent">
<a id="pgfId-1014909"></a>g +&#160;&#160; g + (s-2g)</pre>

<p>
<a id="pgfId-1014910"></a>This results in this calculation of the Dracula X value.</p>

<pre class="webflare-courier-new webflare-indent1 codeContent">
<a id="pgfId-1014911"></a>x = (2 (-1)g+s) /</pre>
<h3>
<a id="pgfId-1014912"></a>Translation Pitfalls</h3>

<p>
<a id="pgfId-1014913"></a>The Dracula check has two independent dimensions which need not be consistent with each other or consistent with an overall measurement philosophy. It is anticipated therefore that the dimensions derived for the Diva verification checks from translation of corner to corner and corner to edge will be different from each other.</p>
<p>
<a id="pgfId-1014914"></a>The translation cannot work if in the Dracula check, the dimension X is greater than the dimension S. Also, the values cannot be computed if <img width="36" height="33" src="images/appB-7.gif" />
 (the corner check dimension) is less than S. This would violate the basic spacing requirement that nothing comes closer than S at any point.</p>
<p>
<a id="pgfId-1014918"></a>Even if the numbers map from the Dracula check to the Diva verification check, the results need not be the same. The diagram illustrates this.</p>

<div class="webflare-div-image">
<img width="650" height="410" src="images/appB-8.gif" /></div>

<p>
<a id="pgfId-1014944"></a>This diagram superimposes the checking methodologies of Dracula and Diva verification for corner to edge separation. The dark area is one example of an area which if it was part of the original polygon would not be treated as an error by Dracula but, would be an error in Diva verification.</p>

<br /><a href="#pagetop">Return to top</a><br /></div>
<!-- Begin Buttons --><!-- End Buttons -->
<footer><nav class="navigation"><b><em><a href="appA.html" id="prev" title="What&#8217;s New In Diva">What&#8217;s New In  ...</a></em></b><b><em><a href="appC.html" id="nex" title="Improving Hierarchical DRC Performance">Improving Hierarchical DRC Per ...</a></em></b></nav><div>
            For further assistance, contact <a href="https://support.cadence.com">Cadence Online Support</a>. Copyright &#169; 2023, <a href="https://www.cadence.com">Cadence Design Systems, Inc.</a> All rights reserved. 
          </div></footer>
 

 <div id="cad_image_modal" style="background-color: rgba(0, 0, 0, 0.6);"><center id="cad_image_modal_center">&#160;⠀ </center><span style="margin-right:50px;margin-top:100px;font-weight:bold;font-size:20px;background:#e5e5e5;border:1px solid #e5e5e5;border-radius:25px;height:30px;width:20px;padding-left:6px;padding-top:2px;color: black;" onclick="document.querySelector('#cad_image_modal').classList.remove('opac');">X</span></div> 

</body></html>